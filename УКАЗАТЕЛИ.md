# Указатели в языке С++

## Содержание
1. [Введение в указатели](#введение-в-указатели)
2. [Основные концепции](#основные-концепции)
3. [Объявление и инициализация указателей](#объявление-и-инициализация-указателей)
4. [Операции с указателями](#операции-с-указателями)
5. [Указатели и массивы](#указатели-и-массивы)
6. [Указатели и функции](#указатели-и-функции)
7. [Динамическое выделение памяти](#динамическое-выделение-памяти)
8. [Указатели на указатели](#указатели-на-указатели)
9. [Частые ошибки и их избежание](#частые-ошибки-и-их-избежание)
10. [100 Практических задач](#100-практических-задач)

---

## Введение в указатели

**Указатель** — это переменная, которая хранит адрес памяти другой переменной. Указатели являются одной из самых мощных и одновременно сложных концепций в С++. Они позволяют писать эффективный код, работать с динамической памятью, создавать сложные структуры данных и передавать переменные по ссылке в функции.

### Зачем нужны указатели?

- **Динамическое выделение памяти**: создание переменных во время выполнения программы
- **Эффективная передача данных**: передача адреса вместо копирования больших объектов
- **Работа со сложными структурами**: связные списки, деревья, графы
- **Функциональное программирование**: указатели на функции
- **Объектно-ориентированное программирование**: работа с объектами через указатели

---

## Основные концепции

### Адрес памяти

Каждая переменная в памяти компьютера имеет адрес. Например:

```cpp
int x = 5;
```

Переменная `x` занимает определённую ячейку памяти, допустим, по адресу `0x7fff5fbff8ac`.

### Операторы для работы с указателями

| Оператор | Название | Описание |
|----------|----------|---------|
| `&` | Адрес | Получить адрес переменной |
| `*` | Разыменование | Получить значение по адресу |
| `->` | Стрелка | Доступ к членам структуры через указатель |
| `[]` | Индекс | Доступ к элементам массива через указатель |

### Примеры операторов

```cpp
int x = 10;
int* ptr = &x;    // ptr содержит адрес x

cout << &x;       // Выводит адрес x
cout << ptr;      // Выводит то же самое
cout << *ptr;     // Выводит значение x (10)
cout << x;        // Также выводит 10
```

---

## Объявление и инициализация указателей

### Синтаксис объявления

```cpp
тип_данных* имя_указателя;
```

### Примеры объявлений

```cpp
int* ptr1;              // Указатель на целое число
double* ptr2;           // Указатель на вещественное число
char* ptr3;             // Указатель на символ
int** ptr4;             // Указатель на указатель на целое число
int* ptr5, ptr6;        // ptr5 - указатель на int, ptr6 - просто int
int *ptr7, *ptr8;       // Оба указатели на int
```

### Инициализация указателей

```cpp
int x = 42;
int* ptr = &x;          // Инициализация адресом существующей переменной

int* ptr2 = nullptr;    // Инициализация нулевым указателем (C++11)
int* ptr3 = NULL;       // Старый способ (до C++11)
int* ptr4 = 0;          // Также нулевой указатель
```

### Проверка на nullptr

```cpp
int* ptr = nullptr;

if (ptr != nullptr) {
    cout << *ptr;   // Это выполнится только если ptr != nullptr
}

if (ptr) {          // Эквивалентно ptr != nullptr
    cout << *ptr;
}
```

---

## Операции с указателями

### Разыменование

Разыменование — это получение значения переменной по адресу, на который указывает указатель.

```cpp
int x = 100;
int* ptr = &x;

cout << *ptr;       // Выводит 100
*ptr = 200;         // Изменяет x на 200
cout << x;          // Выводит 200
```

### Получение адреса

```cpp
int x = 50;
int* ptr = &x;

cout << &x;         // Адрес x
cout << ptr;        // То же самое
cout << &ptr;       // Адрес самого указателя (отличается от &x)
```

### Арифметика указателей

```cpp
int arr[] = {1, 2, 3, 4, 5};
int* ptr = arr;     // Указатель на первый элемент

ptr++;              // Указатель перемещается на следующий элемент
ptr += 2;           // Указатель перемещается на 2 элемента вперёд
ptr--;              // Указатель перемещается на один элемент назад

cout << *ptr;       // Выводит значение в текущей позиции
```

### Сравнение указателей

```cpp
int x = 1, y = 2;
int* ptr1 = &x;
int* ptr2 = &y;
int* ptr3 = &x;

cout << (ptr1 == ptr3);     // true (оба указывают на x)
cout << (ptr1 == ptr2);     // false (указывают на разные переменные)
cout << (ptr1 < ptr2);      // зависит от расположения в памяти
```

---

## Указатели и массивы

### Связь между указателями и массивами

Имя массива — это указатель на его первый элемент.

```cpp
int arr[] = {10, 20, 30, 40, 50};

int* ptr = arr;         // Эквивалентно int* ptr = &arr[0]
cout << *ptr;           // Выводит 10
cout << *(ptr + 1);     // Выводит 20
cout << *(ptr + 4);     // Выводит 50
```

### Доступ к элементам через указатель

```cpp
int arr[] = {1, 2, 3, 4, 5};
int* ptr = arr;

// Все эти способы эквивалентны:
cout << arr[2];         // Выводит 3
cout << ptr[2];         // Выводит 3
cout << *(arr + 2);     // Выводит 3
cout << *(ptr + 2);     // Выводит 3
```

### Прохождение по массиву

```cpp
int arr[] = {1, 2, 3, 4, 5};
int size = 5;

// Способ 1: с использованием индексов
for (int i = 0; i < size; i++) {
    cout << arr[i] << " ";
}

// Способ 2: с использованием указателя
int* ptr = arr;
for (int i = 0; i < size; i++) {
    cout << *(ptr + i) << " ";
}

// Способ 3: инкремент указателя
for (int* p = arr; p < arr + size; p++) {
    cout << *p << " ";
}
```

---

## Указатели и функции

### Передача параметров по указателю

```cpp
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5, y = 10;
    swap(&x, &y);
    cout << x << " " << y;      // Выводит 10 5
}
```

### Функции, возвращающие указатели

```cpp
// Внимание! Это опасный код - возвращение указателя на локальную переменную
int* dangerousFunction() {
    int x = 42;
    return &x;      // Ошибка! x будет уничтожена по выходе из функции
}

// Правильный способ - возвращение указателя на динамическую память
int* safeFunction() {
    int* ptr = new int(42);
    return ptr;     // Это безопасно
}
```

### Указатели на функции

```cpp
int add(int a, int b) {
    return a + b;
}

int main() {
    int (*funcPtr)(int, int) = &add;    // Указатель на функцию
    int result = funcPtr(3, 4);         // Результат: 7
    cout << result;
}
```

---

## Динамическое выделение памяти

### Оператор new

Оператор `new` выделяет память в динамической памяти (heap) и возвращает указатель на выделенную область.

```cpp
int* ptr = new int;         // Выделяет память для одного int
*ptr = 42;                  // Присваивает значение
cout << *ptr;               // Выводит 42

delete ptr;                 // Освобождает память
ptr = nullptr;              // Хорошая практика
```

### Инициализация при выделении памяти

```cpp
int* ptr1 = new int(42);            // Выделяет и инициализирует значением 42
double* ptr2 = new double(3.14);    // Выделяет и инициализирует значением 3.14
char* ptr3 = new char('A');         // Выделяет и инициализирует символом 'A'
```

### Выделение памяти для массивов

```cpp
int* arr = new int[5];          // Выделяет память для массива из 5 int
arr[0] = 10;
arr[1] = 20;

delete[] arr;                   // Освобождает память (используется delete[])
arr = nullptr;
```

### Опасности утечки памяти

```cpp
// Утечка памяти - забыли освободить память
void badFunction() {
    int* ptr = new int(42);
    cout << *ptr;
    // Функция завершается, но память не освобождена!
}

// Правильный способ
void goodFunction() {
    int* ptr = new int(42);
    cout << *ptr;
    delete ptr;
    ptr = nullptr;
}
```

### RAII и умные указатели (C++11+)

```cpp
#include <memory>

// Автоматическое управление памятью
void smartFunction() {
    std::unique_ptr<int> ptr(new int(42));
    cout << *ptr;
    // Память автоматически освобождается при выходе из функции
}
```

---

## Указатели на указатели

### Объявление

```cpp
int x = 42;
int* ptr1 = &x;             // Указатель на int
int** ptr2 = &ptr1;         // Указатель на указатель на int
```

### Разыменование двойного указателя

```cpp
int x = 42;
int* ptr1 = &x;
int** ptr2 = &ptr1;

cout << *ptr2;              // Выводит адрес x
cout << **ptr2;             // Выводит 42
cout << x;                  // Выводит 42

**ptr2 = 100;               // Изменяет x на 100
cout << x;                  // Выводит 100
```

### Использование в функциях

```cpp
void changeValue(int** pptr) {
    **pptr = 999;
}

void changePointer(int** pptr, int* newPtr) {
    *pptr = newPtr;
}

int main() {
    int x = 42;
    int* ptr = &x;
    
    changeValue(&ptr);      // Передаём адрес указателя
    cout << *ptr;           // Выводит 999
}
```

---

## Частые ошибки и их избежание

### Ошибка 1: Разыменование нулевого указателя

```cpp
int* ptr = nullptr;
cout << *ptr;               // Ошибка! Undefined Behavior (неопределённое поведение)
```

**Решение**: Всегда проверяйте указатели перед разыменованием:

```cpp
if (ptr != nullptr) {
    cout << *ptr;
}
```

### Ошибка 2: Возвращение указателя на локальную переменную

```cpp
int* getNumber() {
    int x = 42;
    return &x;              // Ошибка! x уничтожится по выходе из функции
}
```

**Решение**: Используйте динамическую память или возвращайте значение:

```cpp
int* getNumber() {
    int* ptr = new int(42);
    return ptr;
}

// ИЛИ

int getNumber() {
    return 42;
}
```

### Ошибка 3: Утечка памяти

```cpp
void leak() {
    int* ptr = new int(42);
    ptr = nullptr;          // Ошибка! Забыли delete перед переприсваиванием
}
```

**Решение**: Освобождайте память перед переприсваиванием:

```cpp
void noLeak() {
    int* ptr = new int(42);
    delete ptr;
    ptr = nullptr;
}
```

### Ошибка 4: Двойное удаление (double delete)

```cpp
int* ptr = new int(42);
delete ptr;
delete ptr;                 // Ошибка! Undefined Behavior
```

**Решение**: Устанавливайте nullptr после delete:

```cpp
int* ptr = new int(42);
delete ptr;
ptr = nullptr;
// Теперь безопасно проверить: if (ptr) не выполнится
```

### Ошибка 5: Неправильное использование delete[] для одного элемента

```cpp
int* ptr = new int(42);
delete[] ptr;               // Ошибка! Используйте delete, а не delete[]
```

**Решение**: Используйте правильный оператор удаления:

```cpp
int* single = new int(42);
delete single;              // Правильно

int* array = new int[10];
delete[] array;             // Правильно
```

---

# Практические задания

### Пример 1: Обмен значений двух переменных

**Задача**: Написать функцию, которая обменивает значения двух переменных, используя указатели.

**Решение**:

```cpp
#include <iostream>
using namespace std;

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 10, y = 20;
    cout << "До обмена: x = " << x << ", y = " << y << endl;
    
    swap(&x, &y);
    
    cout << "После обмена: x = " << x << ", y = " << y << endl;
    return 0;
}
```

**Вывод**:
```
До обмена: x = 10, y = 20
После обмена: x = 20, y = 10
```

**Объяснение**: Функция принимает два указателя на переменные. Через разыменование `*a` и `*b` получаем значения переменных и обмениваем их, используя временную переменную `temp`.

---

### Пример 2: Сумма элементов массива

**Задача**: Написать функцию, которая вычисляет сумму элементов массива, используя указатели.

**Решение**:

```cpp
#include <iostream>
using namespace std;

int sumArray(int* arr, int size) {
    int sum = 0;
    for (int i = 0; i < size; i++) {
        sum += *(arr + i);  // Эквивалентно sum += arr[i];
    }
    return sum;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int size = 5;
    
    int total = sumArray(arr, size);
    
    cout << "Сумма элементов: " << total << endl;
    return 0;
}
```

**Вывод**:
```
Сумма элементов: 15
```

**Объяснение**: Функция получает указатель на первый элемент массива и его размер. Используя арифметику указателей `(arr + i)` и разыменование `*(arr + i)`, мы получаем доступ к каждому элементу и суммируем их.

---

## Задачи для самостоятельного решения

### Базовые задачи 

1. Объявите указатель на целое число и присвойте ему адрес переменной целого типа. Выведите значение через указатель.

2. Напишите программу, которая получает адрес переменной и выводит этот адрес на экран.

3. Объявите три указателя на целые числа и присвойте им значения NULL (nullptr). Проверьте, равны ли они nullptr.

4. Напишите функцию, которая принимает два целых числа через указатели и выводит большее число.

5. Напишите функцию, которая увеличивает значение переменной, переданной через указатель, на 10.

6. Объявите указатель на символ и инициализируйте его адресом переменной символа. Выведите значение.

7. Напишите функцию, которая принимает указатель на double и возвращает квадрат этого числа.

8. Объявите массив из 5 целых чисел и создайте указатель на первый элемент. Выведите все элементы через указатель.

9. Напишите функцию, которая принимает указатель на целое число и устанавливает его значение равным 0.

10. Объявите два указателя на целые числа. Напишите код, который меняет, на какие переменные они указывают.

11. Напишите функцию, которая принимает указатель на целое число и возвращает указатель на новую выделенную память с тем же значением.

12. Напишите программу, которая работает с массивом целых чисел через указатель и находит максимальный элемент.

13. Создайте функцию, которая обнуляет элементы массива (передав его через указатель).

14. Напишите функцию для нахождения количества отрицательных чисел в массиве через указатель.

15. Напишите программу, которая выводит адреса всех элементов массива.

16. Создайте функцию, которая проверяет, являются ли два указателя указателями на один и тот же объект.

17. Напишите функцию, которая увеличивает значение всех элементов массива на переданное значение (параметр).

18. Напишите программу, которая копирует значение одной переменной в другую, используя указатели.

19. Создайте функцию, которая инвертирует знак числа, переданного через указатель.

20. Напишите программу, которая работает с указателями и выводит адреса локальных переменных функции.

### Операции с указателями (21-40)

21. Напишите функцию, которая вычисляет среднее арифметическое трёх чисел, переданных через указатели.

22. Напишите программу, которая работает с арифметикой указателей для перемещения по массиву.

23. Создайте функцию, которая принимает два указателя и возвращает указатель на больший элемент.

24. Напишите функцию для поиска элемента в массиве, возвращая указатель на найденный элемент.

25. Напишите программу, которая считает количество элементов между двумя указателями в массиве.

26. Создайте функцию, которая обращает массив, используя две указателя (спереди и сзади).

27. Напишите программу для вычисления расстояния (разницы адресов) между двумя указателями.

28. Создайте функцию сортировки массива с использованием указателей.

29. Напишите функцию, которая проходит по массиву в обратном порядке, используя указатель.

30. Напишите программу, которая сдвигает все элементы массива на одну позицию вправо, используя указатели.

31. Создайте функцию, которая объединяет два массива в третий, используя указатели.

32. Напишите функцию для нахождения суммы чисел между двумя указателями.

33. Напишите программу, которая копирует массив в новый массив, используя указатели.

34. Создайте функцию, которая устанавливает все элементы массива в ноль, используя указатель и арифметику.

35. Напишите функцию, которая находит позицию максимального элемента, возвращая указатель.

36. Напишите программу для вычисления произведения элементов массива через указатель.

37. Создайте функцию, которая проверяет, является ли массив отсортированным, используя указатели.

38. Напишите программу для удаления дубликатов из массива, используя указатели.

39. Создайте функцию для нахождения общих элементов двух массивов, используя указатели.

40. Напишите функцию, которая делит массив на две части по указателю раздела.

### Динамическое выделение памяти (41-60)

41. Напишите программу, которая выделяет память для одного целого числа, присваивает ему значение и освобождает память.

42. Создайте функцию, которая выделяет память для массива размером N и инициализирует его нулями.

43. Напишите программу для создания и использования двумерного динамического массива.

44. Создайте функцию, которая выделяет память для строки (массива символов) и копирует туда строку.

45. Напишите программу, которая динамически выделяет память для трёх массивов разного размера.

46. Создайте функцию, которая перераспределяет память для массива (увеличивает размер).

47. Напишите программу для считывания массива целых чисел с клавиатуры в динамически выделенную память.

48. Создайте функцию, которая выделяет память для двух массивов и объединяет их в третий.

49. Напишите программу, которая выделяет память для структуры данных и инициализирует её значения.

50. Создайте функцию для удаления элемента из динамического массива.

51. Напишите функцию для вставки элемента в динамический массив.

52. Создайте программу для работы с динамическим массивом, используя цикл for.

53. Напишите функцию, которая выделяет память для массива и заполняет его случайными числами.

54. Создайте программу, которая работает с динамическими массивами и находит элементы больше определённого значения.

55. Напишите функцию для копирования динамического массива в новый динамический массив.

56. Создайте программу для обращения динамического массива (перестановка элементов).

57. Напишите функцию для отсортировки динамического массива по возрастанию.

58. Создайте программу, которая выделяет память для массива структур.

59. Напишите функцию для нахождения суммы всех элементов динамического массива.

60. Создайте программу для вычисления среднего значения элементов динамического массива.

### Указатели на указатели (61-75)

61. Объявите указатель на указатель на целое число и продемонстрируйте его работу.

62. Напишите функцию, которая изменяет значение переменной, используя указатель на указатель.

63. Создайте функцию, которая изменяет адрес, на который указывает передаваемый указатель (используя указатель на указатель).

64. Напишите программу, которая создаёт цепочку указателей и работает с ней.

65. Создайте функцию, которая принимает указатель на указатель и устанавливает его на новую динамически выделенную память.

66. Напишите программу для демонстрации трёхуровневого разыменования (int***).

67. Создайте функцию для обмена значениями двух указателей, используя указатель на указатель.

68. Напишите программу для работы с двумерным массивом через указатели на указатели.

69. Создайте функцию, которая создаёт динамический двумерный массив, используя указатель на указатель.

70. Напишите программу для освобождения памяти двумерного массива.

71. Создайте функцию, которая изменяет размер двумерного массива.

72. Напишите программу для копирования двумерного массива.

73. Создайте функцию для нахождения суммы элементов двумерного массива.

74. Напишите программу для отсортировки двумерного массива (по строкам или столбцам).

75. Создайте функцию для вывода двумерного массива, используя указатели на указатели.

### Указатели на функции (76-85)

76. Напишите программу, которая создаёт указатель на функцию и вызывает её через указатель.

77. Создайте две функции сложения и вычитания, затем создайте массив указателей на функции.

78. Напишите функцию, которая принимает указатель на функцию в качестве параметра.

79. Создайте программу с функцией обратного вызова (callback), используя указатель на функцию.

80. Напишите функцию для применения операции к элементам массива (используя указатель на функцию).

81. Создайте калькулятор, использующий указатели на функции для различных операций.

82. Напишите программу для сортировки массива, используя функцию-компаратор, переданную через указатель.

83. Создайте функцию для фильтрации элементов массива, используя предикат (функция-указатель).

84. Напишите программу для применения функции ко всем элементам массива.

85. Создайте функцию для интеграции функции (численное интегрирование), используя указатель на функцию.

### Сложные задачи (86-100)

86. Напишите программу для создания простого связного списка с использованием указателей.

87. Создайте функцию для добавления элемента в связный список.

88. Напишите функцию для удаления элемента из связного списка.

89. Создайте функцию для поиска элемента в связном списке.

90. Напишите программу для обращения связного списка.

91. Создайте функцию для объединения двух связных списков.

92. Напишите программу для вывода связного списка на экран.

93. Создайте функцию для удаления всего связного списка (освобождение памяти).

94. Напишите программу для сортировки связного списка.

95. Создайте двусвязный список с использованием указателей (на следующий и предыдущий элементы).

96. Напишите программу для создания бинарного дерева поиска, используя указатели.

97. Создайте функцию для вставки элемента в бинарное дерево поиска.

98. Напишите функцию для обхода бинарного дерева (in-order, pre-order, post-order).

99. Создайте функцию для удаления бинарного дерева (освобождение памяти).

100. Напишите программу для работы с графом, представленным матрицей смежности через указатели, включая добавление и удаление рёбер.

---

## Ответы и подсказки

### Подсказки к задачам 1-20

1. Используйте оператор `&` для получения адреса, оператор `*` для разыменования.
2. Выведите адрес с помощью `cout << &переменная;`
3. Используйте `if (ptr == nullptr)` для проверки.
4. Используйте оператор `*` для получения значений через указатели, затем сравните их.
5. Функция должна принимать `int*` и использовать `*ptr += 10;`
6. Аналогично задаче 1, но для типа `char`.
7. Функция вычисляет `(*ptr) * (*ptr)` и возвращает результат.
8. Используйте цикл и арифметику указателей.
9. Используйте оператор присваивания через разыменование: `*ptr = 0;`
10. Используйте временную переменную типа `int*` для обмена.
11. Используйте `new` для выделения памяти и скопируйте значение.
12. Используйте цикл и сравнение для поиска максимума.
13. Используйте цикл и оператор присваивания через разыменование.
14. Используйте цикл и счётчик для подсчёта отрицательных чисел.
15. Используйте `&` для получения адреса каждого элемента и выведите его.
16. Сравните указатели с помощью `==` оператора.
17. Используйте цикл и оператор `+=` через разыменование.
18. Используйте оператор присваивания: `*ptr1 = *ptr2;`
19. Используйте оператор `*ptr = -*ptr;`
20. Выведите адреса локальных переменных с помощью `&`

### Подсказки к задачам 21-40

21. Вычислите среднее как `(*a + *b + *c) / 3.0`
22. Используйте `ptr++`, `ptr += 2` и т.д. для движения по массиву.
23. Сравните `*ptr1` и `*ptr2`, верните правильный указатель.
24. Используйте цикл для поиска и верните `&arr[i]` или `arr + i` при нахождении.
25. Вычислите `ptr2 - ptr1` (требует арифметику указателей).
26. Используйте два указателя, начиная с начала и конца, обменивайте значения.
27. Вычислите разницу адресов: `ptr2 - ptr1`.
28. Используйте алгоритм сортировки (например, пузырьковую сортировку) с указателями.
29. Начните с конца массива и уменьшайте указатель.
30. Переместите элементы от конца к началу.
31. Используйте три указателя для прохождения по двум массивам и заполнения третьего.
32. Используйте цикл от первого до второго указателя и суммируйте.
33. Выделите новый массив и скопируйте элементы.
34. Используйте цикл и `*(ptr + i) = 0`.
35. Отслеживайте максимальное значение и возвращайте указатель на него.
36. Используйте цикл и умножайте значения.
37. Проверьте, что каждый элемент <= следующему элементу.
38. Используйте два указателя для сравнения элементов.
39. Используйте вложенные циклы для сравнения элементов двух массивов.
40. Используйте указатель для разделения и переупорядочения элементов.

### Подсказки к задачам 41-60

41. Используйте `new` для выделения, присваивания значения и `delete` для освобождения.
42. Используйте `new[]` для выделения массива, инициализируйте в цикле.
43. Используйте два уровня `new[]` для создания двумерного массива.
44. Используйте `new[]` для выделения памяти под строку, затем скопируйте строку.
45. Используйте три разных вызова `new[]` для трёх массивов разного размера.
46. Создайте новый массив большего размера, скопируйте элементы, удалите старый массив.
47. Используйте `cin` для считывания элементов в динамический массив.
48. Выделите третий массив размером `size1 + size2`, скопируйте элементы из обоих массивов.
49. Используйте `new` для выделения памяти под структуру.
50. Создайте новый массив без удаляемого элемента.
51. Создайте новый массив с дополнительным местом, скопируйте элементы, вставьте новый.
52. Используйте цикл `for` для работы с динамическим массивом.
53. Используйте `rand()` для генерации случайных чисел.
54. Используйте цикл для проверки условия и сбора подходящих элементов.
55. Выделите новый массив, скопируйте элементы.
56. Используйте два указателя и обменивайте значения.
57. Используйте алгоритм сортировки (например, quicksort или mergesort).
58. Выделите массив структур с помощью `new[]`.
59. Используйте цикл для суммирования элементов.
60. Вычислите сумму и разделите на размер массива.

### Подсказки к задачам 61-75

61. Объявите как `int* ptr1; int** ptr2 = &ptr1;` и работайте с разыменованием.
62. Используйте `**pptr` для изменения значения через двойное разыменование.
63. Используйте `*pptr = новый_адрес;` для изменения адреса.
64. Создайте несколько указателей и установите цепочку между ними.
65. Используйте `*pptr = new тип;` для выделения памяти.
66. Используйте `int*** ppp;` и работайте с трёхуровневым разыменованием.
67. Создайте функцию, которая обменивает значения `*ptr1` и `*ptr2`.
68. Используйте указатель на указатель для доступа к элементам двумерного массива.
69. Выделите первый уровень указателей на строки, затем каждую строку.
70. Используйте цикл для удаления каждой строки, затем удалите массив строк.
71. Создайте новый двумерный массив большего размера, скопируйте элементы.
72. Выделите новый двумерный массив и скопируйте элементы.
73. Используйте вложенные циклы для суммирования элементов.
74. Используйте алгоритм сортировки для строк или столбцов.
75. Используйте вложенные циклы и разыменование указателей.

### Подсказки к задачам 76-85

76. Объявите как `int (*funcPtr)(int, int) = &функция;` и вызовите через указатель.
77. Создайте массив указателей на функции: `int (*arr[2])(int, int) = {add, subtract};`
78. Используйте параметр типа `int (*func)(int)` в сигнатуре функции.
79. Функция обратного вызова вызывается из функции высшего порядка.
80. Используйте указатель на функцию в цикле для применения операции к каждому элементу.
81. Создайте массив указателей на функции для различных операций (+, -, *, /).
82. Используйте функцию-компаратор в алгоритме сортировки (например, qsort из stdlib.h).
83. Используйте цикл и функцию-предикат для выборки элементов.
84. Используйте цикл и вызывайте функцию для каждого элемента.
85. Используйте численное интегрирование (например, методом трапеции или прямоугольников).

### Подсказки к задачам 86-100

86. Создайте структуру с данными и указателем на следующий узел.
87. Выделите новый узел, присвойте данные, установите указатель на следующий.
88. Найдите узел перед удаляемым, установите его указатель, удалите узел.
89. Используйте цикл для прохождения по списку и поиска значения.
90. Используйте три указателя (текущий, следующий, предыдущий) для обращения.
91. Найдите конец первого списка, установите его указатель на начало второго.
92. Используйте цикл для прохождения по списку и вывода значений.
93. Используйте цикл для удаления каждого узла и освобождения памяти.
94. Используйте алгоритм сортировки (например, сортировку вставками).
95. Создайте структуру с указателями на следующий и предыдущий узлы.
96. Создайте структуру с данными и указателями на левое и правое поддеревья.
97. Используйте рекурсию для вставки элемента в правильную позицию.
98. Используйте рекурсию для обхода дерева в разных порядках.
99. Используйте рекурсию для удаления всех узлов дерева.
100. Используйте матрицу смежности и указатели для представления графа, реализуйте функции добавления и удаления рёбер.

---
