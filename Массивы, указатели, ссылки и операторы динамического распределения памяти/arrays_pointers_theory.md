# Массивы, указатели, ссылки и динамическое распределение памяти

## Оглавление
1. [Массивы](#массивы)
2. [Указатели](#указатели)
3. [Ссылки](#ссылки)
4. [Динамическое распределение памяти](#динамическое-распределение-памяти)
5. [Взаимосвязь между массивами и указателями](#взаимосвязь-между-массивами-и-указателями)

---

## Массивы

### Определение
Массив — это контейнер фиксированного размера, который хранит последовательность элементов одного типа данных. Все элементы занимают смежные ячейки памяти.

### Синтаксис объявления
```cpp
// Одномерный массив
тип имя[размер];
int arr[10];  // Массив из 10 целых чисел

// Инициализация
int arr[5] = {1, 2, 3, 4, 5};
int arr[] = {1, 2, 3};  // Размер выводится автоматически

// Многомерный массив
int matrix[3][4];  // Матрица 3x4
int matrix[2][3][4];  // Трёхмерный массив
```

### Свойства массивов
- **Фиксированный размер**: определяется при объявлении и не может быть изменён
- **Непрерывность памяти**: элементы размещаются подряд в памяти
- **Индексирование**: начинается с 0
- **Время доступа**: O(1) — константное за счёт формулы адреса: `address = base_address + index * sizeof(type)`

### Пример использования
```cpp
#include <iostream>
using namespace std;

int main() {
    int scores[5] = {85, 90, 78, 92, 88};
    
    // Доступ к элементам
    cout << "Третий элемент: " << scores[2] << endl;
    
    // Итерация по массиву
    for (int i = 0; i < 5; i++) {
        cout << scores[i] << " ";
    }
    
    // Изменение элемента
    scores[0] = 95;
    
    return 0;
}
```

---

## Указатели

### Определение
Указатель — это переменная, которая хранит адрес памяти другой переменной.

### Объявление и инициализация
```cpp
тип *имя_указателя;

int x = 10;
int *ptr = &x;  // Указатель на переменную x
```

### Операторы для работы с указателями

#### Оператор & (адрес)
```cpp
int x = 5;
int *ptr = &x;  // ptr содержит адрес x
cout << &x << endl;  // Выведет адрес x в памяти
```

#### Оператор * (разыменование)
```cpp
int x = 5;
int *ptr = &x;
cout << *ptr << endl;  // Выведет 5 (значение переменной, на которую указывает ptr)
*ptr = 10;  // Изменит значение x на 10
```

### Арифметика указателей
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;

ptr++;        // Переместиться на следующий элемент
ptr += 2;     // Переместиться на 2 элемента вперёд
ptr--;        // Вернуться на элемент назад

// Вычисление разности указателей
int *ptr1 = &arr[0];
int *ptr2 = &arr[3];
int distance = ptr2 - ptr1;  // distance = 3
```

### Нулевой указатель
```cpp
int *ptr = nullptr;  // Или int *ptr = NULL;
if (ptr != nullptr) {
    cout << *ptr << endl;
}
```

### Указатель на указатель
```cpp
int x = 5;
int *ptr1 = &x;      // Указатель на x
int **ptr2 = &ptr1;  // Указатель на ptr1

cout << **ptr2 << endl;  // Выведет 5
```

### Пример: работа с адресами
```cpp
#include <iostream>
using namespace std;

int main() {
    int age = 25;
    double height = 1.75;
    
    int *ptr_age = &age;
    double *ptr_height = &height;
    
    cout << "Адрес age: " << &age << endl;
    cout << "Значение age через указатель: " << *ptr_age << endl;
    cout << "Размер int: " << sizeof(int) << endl;
    cout << "Размер указателя: " << sizeof(ptr_age) << endl;
    
    return 0;
}
```

---

## Ссылки

### Определение
Ссылка — это альтернативное имя для существующей переменной. Это безопасная альтернатива указателям.

### Синтаксис
```cpp
тип &имя_ссылки = исходная_переменная;

int x = 10;
int &ref = x;  // ref — это ссылка на x
```

### Характеристики ссылок
- **Не занимают память**: ссылка — это просто другое имя для переменной
- **Не могут быть нулевыми**: ссылка всегда ссылается на существующий объект
- **Не могут быть переназначены**: после создания ссылку нельзя переделать на другую переменную
- **Безопасны**: нет риска разыменования нулевого указателя
- **Изменение через ссылку**: влияет на исходную переменную

### Пример использования
```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 5;
    int &ref = x;  // ref — это ссылка на x
    
    cout << "x = " << x << endl;      // Выведет 5
    cout << "ref = " << ref << endl;  // Выведет 5
    
    ref = 10;  // Изменяем x через ссылку
    cout << "x = " << x << endl;      // Выведет 10
    
    return 0;
}
```

### Ссылки в функциях
```cpp
// Передача по ссылке (изменения влияют на исходную переменную)
void increment(int &num) {
    num++;
}

// Const ссылка (только чтение)
void print(const int &num) {
    cout << num << endl;
}

int main() {
    int x = 5;
    increment(x);  // x становится 6
    print(x);
    return 0;
}
```

### Const ссылки
```cpp
const int &ref = x;  // Ссылка на const переменную
// Нельзя изменить значение через ref
```

### Отличия указателей и ссылок

| Характеристика | Указатель | Ссылка |
|---|---|---|
| Может быть нулевым | Да | Нет |
| Может быть переназначен | Да | Нет |
| Требует разыменования (*) | Да | Нет |
| Занимает память | Да | Нет |
| Может быть массивом | Да | Нет |
| Обязателен при создании | Нет | Да |

---

## Динамическое распределение памяти

### Определение
Динамическое распределение — это выделение памяти во время выполнения программы в куче (heap), а не на стеке (stack).

### Стек vs Куча

| Характеристика | Стек | Куча |
|---|---|---|
| Размер | Ограничен | Больший размер |
| Скорость | Быстрее | Медленнее |
| Управление | Автоматическое | Ручное |
| Время жизни | До конца области видимости | До освобождения |
| Фрагментация | Нет | Возможна |

### Оператор new
```cpp
// Выделение памяти для одного объекта
тип *ptr = new тип;
int *ptr = new int;
int *ptr = new int(5);  // С инициализацией

// Выделение памяти для массива
тип *ptr = new тип[размер];
int *arr = new int[10];
int *arr = new int[5]{1, 2, 3, 4, 5};
```

### Оператор delete
```cpp
// Освобождение памяти для одного объекта
delete ptr;

// Освобождение памяти для массива
delete[] arr;

// Хорошая практика: присвоить nullptr после delete
ptr = nullptr;
```

### Пример динамического массива
```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cout << "Введите размер массива: ";
    cin >> n;
    
    // Выделяем память
    int *arr = new int[n];
    
    // Инициализируем
    for (int i = 0; i < n; i++) {
        arr[i] = i * 2;
    }
    
    // Используем
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    
    // Освобождаем память
    delete[] arr;
    arr = nullptr;
    
    return 0;
}
```

### Динамические объекты
```cpp
class Person {
public:
    Person(string name) : name(name) {}
    void greet() { cout << "Привет, я " << name << endl; }
private:
    string name;
};

int main() {
    // Создание динамического объекта
    Person *person = new Person("Иван");
    person->greet();
    
    // Освобождение памяти
    delete person;
    person = nullptr;
    
    return 0;
}
```

### Утечки памяти
```cpp
// ❌ НЕПРАВИЛЬНО - утечка памяти
int *ptr = new int[100];
// Забыли delete[]

// ❌ НЕПРАВИЛЬНО - double delete
int *ptr = new int(5);
delete ptr;
delete ptr;  // Ошибка!

// ✓ ПРАВИЛЬНО
int *ptr = new int(5);
delete ptr;
ptr = nullptr;
```

### Умные указатели (Smart Pointers)
```cpp
#include <memory>

// unique_ptr - исключительное владение
std::unique_ptr<int> ptr1(new int(5));
std::unique_ptr<int> ptr2 = std::make_unique<int>(5);

// shared_ptr - совместное владение
std::shared_ptr<int> ptr3 = std::make_shared<int>(5);

// Автоматическое удаление при выходе из области видимости
// Нет необходимости в delete
```

---

## Взаимосвязь между массивами и указателями

### Массивы как указатели
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;  // arr автоматически конвертируется в указатель на первый элемент

cout << *ptr << endl;        // Выведет 1
cout << *(ptr + 1) << endl;  // Выведет 2
cout << ptr[2] << endl;      // Выведет 3
```

### Индексирование через указатель
```cpp
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;

// Все эти выражения эквивалентны:
arr[2] == *(arr + 2) == ptr[2] == *(ptr + 2)  // Все равны 30
```

### Динамический массив vs статический

```cpp
// Статический массив (размер известен на этапе компиляции)
int static_arr[10];

// Динамический массив (размер может быть неизвестен)
int n;
cin >> n;
int *dynamic_arr = new int[n];
// ...
delete[] dynamic_arr;
```

### Передача массива в функцию
```cpp
// Массив передаётся как указатель на первый элемент
void print_array(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    print_array(arr, 5);  // arr преобразуется в указатель
    
    // Или с динамическим массивом
    int *dyn_arr = new int[5]{1, 2, 3, 4, 5};
    print_array(dyn_arr, 5);
    delete[] dyn_arr;
    
    return 0;
}
```

### Двумерные динамические массивы
```cpp
int rows = 3, cols = 4;

// Способ 1: Массив указателей
int **matrix = new int*[rows];
for (int i = 0; i < rows; i++) {
    matrix[i] = new int[cols];
}

// Использование
matrix[0][0] = 5;

// Освобождение
for (int i = 0; i < rows; i++) {
    delete[] matrix[i];
}
delete[] matrix;

// Способ 2: Один непрерывный блок памяти
int *matrix = new int[rows * cols];
matrix[i * cols + j] = 5;  // Доступ к элементу (i, j)
delete[] matrix;
```

---

## Практические советы

### Правила безопасности работы с памятью
1. **Всегда инициализируйте указатели**: `int *ptr = nullptr;`
2. **Проверяйте результат new**: может вернуть nullptr, если памяти недостаточно
3. **Используйте delete для каждого new**: 1 выделение = 1 освобождение
4. **Используйте delete[] для массивов**: не используйте delete для массивов!
5. **Избегайте висячих указателей**: присваивайте nullptr после delete
6. **Используйте RAII и умные указатели**: где возможно, используйте unique_ptr или shared_ptr

### Отладка утечек памяти
```cpp
// На Linux/Mac с использованием valgrind
// valgrind --leak-check=full ./program

// На Windows с использованием Dr. Memory
// drmemory -- program.exe
```

### Рекомендации по производительности
- Предпочитайте статические массивы динамическим, если размер известен
- Выделяйте память один раз на большой блок вместо частых выделений
- Избегайте фрагментации памяти через пулы объектов
- Используйте move семантику для оптимизации производительности

---

## Заключение

Понимание массивов, указателей, ссылок и динамической памяти — критически важно для написания эффективного и безопасного кода на C++. Правильное управление памятью предотвращает утечки, повышает производительность и улучшает надёжность программ.
