# Практические задачи: Массивы, указатели, ссылки и динамическая память

## Общие инструкции
- Все задачи предназначены для практики на C++
- Рекомендуется решить задачи в предложенном порядке
- Для каждой задачи ниже представлено решение (в конце файла)

---

# Полный список задач (100 шт)

### Раздел 1: Массивы (Задачи 1-20)

1. Создать статический массив из 10 целых чисел, заполнить его значениями от 1 до 10 и вывести все элементы.

2. Найти сумму всех элементов массива из 5 элементов.

3. Найти максимальный элемент в массиве из 7 целых чисел.

4. Найти минимальный элемент в массиве и его индекс.

5. Развернуть массив задом наперёд (in-place).

6. Проверить, является ли массив палиндромом.

7. Подсчитать количество чётных и нечётных элементов в массиве.

8. Найти произведение всех элементов массива.

9. Вычислить среднее арифметическое элементов массива.

10. Найти второй по величине элемент в массиве.

11. Вычислить дисперсию элементов массива.

12. Найти все элементы, которые больше среднего значения.

13. Сдвинуть все элементы массива на одну позицию вправо.

14. Удалить все нулевые элементы из массива (создав новый массив).

15. Слить два отсортированных массива в один отсортированный.

16. Разбить массив на две половины и вывести отдельно.

17. Найти элемент, который встречается чаще всего.

18. Проверить, содержит ли массив дубликаты.

19. Найти все пары элементов, сумма которых равна целевому значению.

20. Заполнить двумерный массив 3x3 числами от 1 до 9 и вывести как матрицу.

### Раздел 2: Указатели (Задачи 21-40)

21. Создать переменную, вывести её адрес и значение через указатель.

22. Создать указатель на указатель и вывести значение переменной через него.

23. Реализовать арифметику указателей: создать массив, переместиться по нему с помощью указателя.

24. Поменять местами два числа, используя указатели.

25. Найти длину строки, используя указатель.

26. Скопировать строку в новую, используя указатели.

27. Создать функцию, которая изменяет значение переменной через указатель.

28. Вычислить расстояние между двумя указателями на элементы массива.

29. Реализовать функцию reverse для массива через указатели.

30. Создать функцию поиска элемента в массиве, возвращающую указатель.

31. Реализовать сортировку массива через указатели (bubble sort).

32. Создать функцию, которая выполняет операцию над всеми элементами через указатели.

33. Создать двумерный динамический массив через указатели.

34. Работа с NULL указателем: проверка, инициализация.

35. Создать функцию для удаления дубликатов из массива через указатели.

36. Реализовать функцию shift для сдвига элементов массива через указатели.

37. Создать функцию merge для слияния двух массивов через указатели.

38. Работа с const указателями: создание и использование.

39. Реализовать функцию поиска подмассива в массиве через указатели.

40. Создать функцию для интерпретации массива как указателя на элементы разного типа.

### Раздел 3: Ссылки (Задачи 41-55)

41. Создать ссылку на переменную и изменить её значение через ссылку.

42. Передать переменную в функцию по ссылке и изменить её.

43. Использовать const ссылку для защиты от изменения переменной.

44. Вернуть ссылку из функции (опасно, но для практики).

45. Создать функцию swap, используя ссылки.

46. Создать функцию для увеличения всех элементов массива через ссылку.

47. Создать класс с методом, принимающим ссылку на другой объект.

48. Использовать ссылку в цикле for (range-based for loop).

49. Передать массив по ссылке в функцию.

50. Создать функцию, возвращающую ссылку на локальную переменную (показать опасность).

51. Использовать ссылку для создания синонима переменной.

52. Создать функцию с параметром const ссылка и попытаться его изменить.

53. Использовать rvalue ссылку (&& ref).

54. Создать вектор и работать с ним через ссылки.

55. Сравнить время выполнения передачи по значению vs по ссылке.

### Раздел 4: Динамическая память (Задачи 56-75)

56. Выделить память для одной переменной через new и освободить через delete.

57. Выделить память для массива через new и освободить через delete[].

58. Создать динамический массив размером, указанным пользователем.

59. Реализовать динамический стек (Stack) с использованием new/delete.

60. Реализовать динамическую очередь (Queue) с использованием new/delete.

61. Создать динамическую матрицу (двумерный массив) и работать с ней.

62. Создать класс с динамическими полями и реализовать конструктор/деструктор.

63. Создать класс Vector с динамическим массивом (как std::vector).

64. Обработать исключение при выделении памяти (недостаток памяти).

65. Создать простую систему управления памятью (пул объектов).

66. Реализовать глубокое копирование для класса с динамическими данными.

67. Реализовать move семантику для класса с динамическими данными.

68. Создать linked list (связный список) вручную.

69. Создать binary tree (бинарное дерево) вручную.

70. Реализовать graph (граф) с динамическими структурами.

71. Создать имитацию работы garbage collector'а.

72. Выявить и исправить утечку памяти в предоставленном коде.

73. Создать класс, использующий unique_ptr для автоматического управления памятью.

74. Создать класс, использующий shared_ptr для совместного владения ресурсом.

75. Реализовать собственный умный указатель (RAII паттерн).

### Раздел 5: Комбинированные задачи (Задачи 76-100)

76. Создать функцию для работы с массивом через указатели и вернуть результат через ссылку.

77. Реализовать сортировку массива через указатели и передать результат через ссылку.

78. Создать динамический массив, работать с ним через указатели, вернуть статистику через ссылку.

79. Создать класс с использованием всех трёх концепций: массивы, указатели, ссылки, динамическая память.

80. Реализовать функцию-шаблон для работы с массивами через указатели.

81. Создать иерархию классов с использованием виртуальных функций и динамической памяти.

82. Реализовать функцию с переменным числом аргументов, работающую с массивами.

83. Создать систему для работы с матрицами с использованием динамической памяти.

84. Реализовать функцию для работы с вложенными динамическими структурами.

85. Создать контейнер (как std::vector), работающий с указателями и памятью.

86. Реализовать паттерн Factory для создания объектов в динамической памяти.

87. Создать систему пулинга памяти для оптимизации выделения объектов.

88. Реализовать паттерн Observer с использованием динамических указателей.

89. Создать систему управления ресурсами с использованием RAII.

90. Реализовать двусвязный список с использованием динамической памяти.

91. Создать хеш-таблицу с динамическим выделением памяти.

92. Реализовать сортировку данных, хранящихся в динамической памяти.

93. Создать индексную структуру для быстрого поиска в динамическом массиве.

94. Реализовать систему кеширования с динамическим выделением памяти.

95. Создать граф и реализовать DFS/BFS с использованием динамической памяти.

96. Реализовать систему парсинга выражений с использованием указателей.

97. Создать мульти-уровневую структуру данных с динамической памятью.

98. Реализовать систему сериализации/десериализации объектов в память.

99. Создать паттерн Composite для древовидных структур с динамической памятью.

100. Реализовать полнофункциональный контейнер с итераторами, используя динамическую память.

---

# РЕШЁННЫЕ ЗАДАЧИ (5 случайно выбранных)

## Решение Задачи 7: Подсчитать количество чётных и нечётных элементов

**Описание**: Дан массив целых чисел. Нужно подсчитать, сколько в нём чётных и сколько нечётных элементов.

```cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size = 10;
    
    int even_count = 0;
    int odd_count = 0;
    
    // Подсчитываем чётные и нечётные элементы
    for (int i = 0; i < size; i++) {
        if (arr[i] % 2 == 0) {
            even_count++;
        } else {
            odd_count++;
        }
    }
    
    cout << "Чётные числа: " << even_count << endl;
    cout << "Нечётные числа: " << odd_count << endl;
    
    return 0;
}
```

**Вывод:**
```
Чётные числа: 5
Нечётные числа: 5
```

**Объяснение**: Используется цикл для итерации по всем элементам массива. Для каждого элемента проверяется остаток от деления на 2 — если 0, то число чётное, иначе нечётное.

---

## Решение Задачи 24: Поменять местами два числа, используя указатели

**Описание**: Создать функцию, которая меняет местами два числа, используя указатели.

```cpp
#include <iostream>
using namespace std;

// Функция для обмена значений через указатели
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 5;
    int y = 10;
    
    cout << "До обмена: x = " << x << ", y = " << y << endl;
    
    // Передаём адреса переменных
    swap(&x, &y);
    
    cout << "После обмена: x = " << x << ", y = " << y << endl;
    
    return 0;
}
```

**Вывод:**
```
До обмена: x = 5, y = 10
После обмена: x = 10, y = 5
```

**Объяснение**: Функция получает указатели на две переменные, разыменовывает их и меняет значения через временную переменную. Благодаря указателям, изменения влияют на исходные переменные в main().

---

## Решение Задачи 41: Создать ссылку на переменную и изменить её значение через ссылку

**Описание**: Создать ссылку на переменную и показать, что изменение значения через ссылку изменяет исходную переменную.

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 20;
    
    // Создаём ссылку на переменную x
    int &ref = x;
    
    cout << "Исходное значение x: " << x << endl;
    cout << "Значение через ссылку ref: " << ref << endl;
    
    // Изменяем значение через ссылку
    ref = 50;
    
    cout << "\nПосле изменения через ссылку:" << endl;
    cout << "Значение x: " << x << endl;
    cout << "Значение ref: " << ref << endl;
    
    return 0;
}
```

**Вывод:**
```
Исходное значение x: 20
Значение через ссылку ref: 20

После изменения через ссылку:
Значение x: 50
Значение ref: 50
```

**Объяснение**: Ссылка ref является альтернативным именем для переменной x. Когда мы изменяем ref, мы изменяем саму переменную x. Ссылка — это просто другое имя для той же ячейки памяти.

---

## Решение Задачи 57: Выделить память для массива через new и освободить через delete[]

**Описание**: Выделить память для массива динамически, заполнить его и освободить память.

```cpp
#include <iostream>
using namespace std;

int main() {
    int size = 5;
    
    // Выделяем память для динамического массива
    int *arr = new int[size];
    
    // Инициализируем массив
    cout << "Введите " << size << " элементов:" << endl;
    for (int i = 0; i < size; i++) {
        arr[i] = (i + 1) * 10;  // Заполняем: 10, 20, 30, 40, 50
    }
    
    // Выводим массив
    cout << "Элементы массива: ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    // Освобождаем память
    delete[] arr;
    arr = nullptr;  // Хорошая практика
    
    cout << "Память освобождена." << endl;
    
    return 0;
}
```

**Вывод:**
```
Введите 5 элементов:
Элементы массива: 10 20 30 40 50 
Память освобождена.
```

**Объяснение**: 
1. Используем `new[]` для выделения памяти под массив
2. Работаем с массивом как обычно
3. Используем `delete[]` для освобождения памяти (важно: не просто `delete`, а `delete[]` для массивов!)
4. Присваиваем `nullptr` — хорошая практика, предотвращающая ошибки

---

## Решение Задачи 78: Создать динамический массив, работать с ним через указатели, вернуть статистику через ссылку

**Описание**: Комбинированная задача, использующая массивы, указатели, ссылки и динамическую память.

```cpp
#include <iostream>
using namespace std;

// Функция для вычисления статистики массива
void getStatistics(int *arr, int size, int &min_val, int &max_val, double &avg) {
    if (size <= 0) return;
    
    min_val = arr[0];
    max_val = arr[0];
    int sum = 0;
    
    for (int i = 0; i < size; i++) {
        if (arr[i] < min_val) min_val = arr[i];
        if (arr[i] > max_val) max_val = arr[i];
        sum += arr[i];
    }
    
    avg = static_cast<double>(sum) / size;
}

int main() {
    int size = 5;
    
    // Выделяем динамический массив
    int *arr = new int[size]{15, 8, 23, 12, 30};
    
    cout << "Массив: ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    // Переменные для статистики (передаём через ссылку)
    int min_val, max_val;
    double avg;
    
    // Вызываем функцию с указателем и ссылками
    getStatistics(arr, size, min_val, max_val, avg);
    
    cout << "Минимум: " << min_val << endl;
    cout << "Максимум: " << max_val << endl;
    cout << "Среднее: " << avg << endl;
    
    // Освобождаем память
    delete[] arr;
    arr = nullptr;
    
    return 0;
}
```

**Вывод:**
```
Массив: 15 8 23 12 30 
Минимум: 8
Максимум: 30
Среднее: 17.6
```

**Объяснение**:
- Используется динамическая память (`new[]` и `delete[]`)
- Массив передаётся в функцию через указатель (`int *arr`)
- Результаты возвращаются через ссылки (`int &min_val`, `int &max_val`, `double &avg`)
- Функция работает с массивом через указатель, используя индексацию
- Это демонстрирует интеграцию всех изученных концепций

---

## Итоги практики

Эти пять задач охватывают:
- **Задача 7**: Работа со статическими массивами
- **Задача 24**: Использование указателей для модификации переменных
- **Задача 41**: Введение в ссылки и их использование
- **Задача 57**: Динамическое выделение памяти и её освобождение
- **Задача 78**: Интеграция всех концепций в одну задачу

Рекомендуется решить остальные 95 задач для полного овладения темой!
