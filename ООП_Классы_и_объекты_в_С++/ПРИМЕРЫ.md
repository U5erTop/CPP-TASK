
# РАЗБОР 10 СЛУЧАЙНЫХ ЗАДАНИЙ ПО ТЕМЕ "КЛАССЫ И ОБЪЕКТЫ В C++"



### Задание №17: Создайте класс String с приватным полем char* str

**Решение:**

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* str;  // Приватный указатель на строку

public:
    // Конструктор по умолчанию
    String() : str(nullptr) {
        str = new char[1];
        str[0] = '\0';
    }

    // Конструктор с параметром
    String(const char* s) {
        if (s == nullptr) {
            str = new char[1];
            str[0] = '\0';
        } else {
            str = new char[strlen(s) + 1];
            strcpy(str, s);
        }
    }

    // Деструктор
    ~String() {
        delete[] str;
    }

    // Метод вывода
    void print() const {
        std::cout << (str ? str : "") << std::endl;
    }
};

int main() {
    String s1;              // Пустая строка
    String s2("Привет");    // Строка из литерала

    s1.print();  // Выведет пустую строку
    s2.print();  // Выведет: Привет

    return 0;
}
```

**Пояснение:**
- Класс содержит приватное поле `char* str` для хранения строки
- Инкапсуляция защищает прямой доступ к внутреннему указателю
- Память выделяется динамически через `new`
- Деструктор освобождает память через `delete[]`


================================================================================


### Задание №53: Реализуйте конструктор копирования для класса String

**Решение:**

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* str;

public:
    String() : str(nullptr) {
        str = new char[1];
        str[0] = '\0';
    }

    String(const char* s) {
        if (s == nullptr) {
            str = new char[1];
            str[0] = '\0';
        } else {
            str = new char[strlen(s) + 1];
            strcpy(str, s);
        }
    }

    // Конструктор копирования (глубокое копирование)
    String(const String& other) {
        std::cout << "Вызван конструктор копирования\n";
        if (other.str == nullptr) {
            str = new char[1];
            str[0] = '\0';
        } else {
            // Выделяем новую память и копируем данные
            str = new char[strlen(other.str) + 1];
            strcpy(str, other.str);
        }
    }

    ~String() {
        delete[] str;
    }

    void print() const {
        std::cout << (str ? str : "") << std::endl;
    }
};

int main() {
    String s1("Оригинал");
    String s2 = s1;  // Вызов конструктора копирования
    String s3(s1);   // Тоже вызов конструктора копирования

    s1.print();  // Выведет: Оригинал
    s2.print();  // Выведет: Оригинал
    s3.print();  // Выведет: Оригинал

    return 0;
}
```

**Пояснение:**
- Конструктор копирования принимает константную ссылку на объект того же класса
- Выполняется **глубокое копирование** - создается новая память
- Без конструктора копирования использовался бы конструктор по умолчанию (поверхностное копирование)
- Это привело бы к двойному удалению одной и той же памяти


================================================================================


### Задание №55: Создайте перегруженные конструкторы для класса Time

**Решение:**

```cpp
#include <iostream>
#include <iomanip>

class Time {
private:
    int hours;
    int minutes;
    int seconds;

    // Приватный метод нормализации времени
    void normalize() {
        if (seconds >= 60) {
            minutes += seconds / 60;
            seconds %= 60;
        }
        if (minutes >= 60) {
            hours += minutes / 60;
            minutes %= 60;
        }
        hours %= 24;  // 24-часовой формат
    }

public:
    // Конструктор по умолчанию (00:00:00)
    Time() : hours(0), minutes(0), seconds(0) {
        std::cout << "Конструктор по умолчанию\n";
    }

    // Конструктор с одним параметром (только часы)
    Time(int h) : hours(h), minutes(0), seconds(0) {
        std::cout << "Конструктор с часами\n";
        normalize();
    }

    // Конструктор с двумя параметрами (часы и минуты)
    Time(int h, int m) : hours(h), minutes(m), seconds(0) {
        std::cout << "Конструктор с часами и минутами\n";
        normalize();
    }

    // Конструктор с тремя параметрами (полное время)
    Time(int h, int m, int s) : hours(h), minutes(m), seconds(s) {
        std::cout << "Конструктор с полным временем\n";
        normalize();
    }

    // Конструктор из строки формата "HH:MM:SS"
    Time(const char* timeStr) {
        std::cout << "Конструктор из строки\n";
        sscanf(timeStr, "%d:%d:%d", &hours, &minutes, &seconds);
        normalize();
    }

    void display() const {
        std::cout << std::setfill('0') << std::setw(2) << hours << ":"
                  << std::setw(2) << minutes << ":"
                  << std::setw(2) << seconds << std::endl;
    }
};

int main() {
    Time t1;              // 00:00:00
    Time t2(14);          // 14:00:00
    Time t3(10, 30);      // 10:30:00
    Time t4(15, 45, 30);  // 15:45:30
    Time t5("09:15:45");  // 09:15:45

    std::cout << "\nВремена:\n";
    t1.display();
    t2.display();
    t3.display();
    t4.display();
    t5.display();

    return 0;
}
```

**Пояснение:**
- Класс имеет 5 перегруженных конструкторов
- Перегрузка позволяет создавать объекты разными способами
- Компилятор выбирает нужный конструктор по числу и типу аргументов
- Метод `normalize()` приводит время к корректному виду


================================================================================


### Задание №116: Создайте метод sort() для сортировки элементов

**Решение:**

```cpp
#include <iostream>
#include <algorithm>

class IntArray {
private:
    int* data;
    int size;

public:
    IntArray(int s) : size(s) {
        data = new int[size];
    }

    ~IntArray() {
        delete[] data;
    }

    // Установка элемента
    void set(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Получение элемента
    int get(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return 0;
    }

    // Метод сортировки (пузырьковая сортировка)
    void sort() {
        for (int i = 0; i < size - 1; i++) {
            for (int j = 0; j < size - i - 1; j++) {
                if (data[j] > data[j + 1]) {
                    // Обмен элементов
                    int temp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = temp;
                }
            }
        }
    }

    // Альтернативный метод сортировки через STL
    void sortSTL() {
        std::sort(data, data + size);
    }

    // Сортировка по убыванию
    void sortDescending() {
        std::sort(data, data + size, std::greater<int>());
    }

    void print() const {
        for (int i = 0; i < size; i++) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    IntArray arr(5);

    // Заполнение массива
    arr.set(0, 64);
    arr.set(1, 34);
    arr.set(2, 25);
    arr.set(3, 12);
    arr.set(4, 90);

    std::cout << "До сортировки: ";
    arr.print();

    arr.sort();

    std::cout << "После сортировки: ";
    arr.print();

    return 0;
}
```

**Пояснение:**
- Метод `sort()` сортирует элементы массива по возрастанию
- Реализована пузырьковая сортировка (простая, но не самая эффективная)
- `sortSTL()` использует стандартную библиотеку (более эффективно)
- `sortDescending()` сортирует по убыванию


================================================================================


### Задание №142: Добавьте метод forEach() для итерации по элементам

**Решение:**

```cpp
#include <iostream>
#include <functional>

class IntArray {
private:
    int* data;
    int size;

public:
    IntArray(int s) : size(s) {
        data = new int[size];
        for (int i = 0; i < size; i++) {
            data[i] = 0;
        }
    }

    ~IntArray() {
        delete[] data;
    }

    void set(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Метод forEach принимает функцию и применяет её к каждому элементу
    void forEach(std::function<void(int&)> func) {
        for (int i = 0; i < size; i++) {
            func(data[i]);  // Применяем функцию к каждому элементу
        }
    }

    // Константная версия forEach (элементы нельзя изменять)
    void forEach(std::function<void(const int&)> func) const {
        for (int i = 0; i < size; i++) {
            func(data[i]);
        }
    }

    void print() const {
        std::cout << "[";
        for (int i = 0; i < size; i++) {
            std::cout << data[i];
            if (i < size - 1) std::cout << ", ";
        }
        std::cout << "]" << std::endl;
    }
};

int main() {
    IntArray arr(5);

    // Заполнение массива
    for (int i = 0; i < 5; i++) {
        arr.set(i, i + 1);  // [1, 2, 3, 4, 5]
    }

    std::cout << "Исходный массив: ";
    arr.print();

    // Пример 1: Вывод каждого элемента
    std::cout << "Элементы: ";
    arr.forEach([](const int& val) {
        std::cout << val << " ";
    });
    std::cout << std::endl;

    // Пример 2: Удвоение каждого элемента
    arr.forEach([](int& val) {
        val *= 2;
    });

    std::cout << "После удвоения: ";
    arr.print();

    // Пример 3: Подсчет суммы
    int sum = 0;
    arr.forEach([&sum](const int& val) {
        sum += val;
    });
    std::cout << "Сумма элементов: " << sum << std::endl;

    return 0;
}
```

**Пояснение:**
- Метод `forEach()` принимает функцию (лямбду или функциональный объект)
- Применяет эту функцию к каждому элементу массива
- Используется `std::function` для гибкости
- Есть две версии: для изменения и только для чтения элементов


================================================================================


### Задание №170: Создайте класс с приватным наследованием для инкапсуляции

**Решение:**

```cpp
#include <iostream>
#include <vector>

// Базовый класс - реализация стека на основе вектора
class VectorStack {
protected:
    std::vector<int> data;

public:
    void push(int value) {
        data.push_back(value);
    }

    void pop() {
        if (!data.empty()) {
            data.pop_back();
        }
    }

    int top() const {
        return data.empty() ? 0 : data.back();
    }

    bool empty() const {
        return data.empty();
    }

    size_t size() const {
        return data.size();
    }
};

// Класс LimitedStack наследует VectorStack приватно
// Скрывает некоторые методы и добавляет ограничение по размеру
class LimitedStack : private VectorStack {
private:
    size_t maxSize;

public:
    LimitedStack(size_t max) : maxSize(max) {}

    // Переопределяем push с проверкой лимита
    bool push(int value) {
        if (data.size() < maxSize) {
            VectorStack::push(value);  // Вызов метода базового класса
            return true;
        }
        std::cout << "Стек переполнен!\n";
        return false;
    }

    // Предоставляем доступ только к нужным методам
    using VectorStack::pop;     // Делаем pop публичным
    using VectorStack::top;     // Делаем top публичным
    using VectorStack::empty;   // Делаем empty публичным

    // size() НЕ делаем публичным - скрываем размер

    size_t capacity() const {
        return maxSize;
    }

    size_t available() const {
        return maxSize - data.size();
    }
};

int main() {
    LimitedStack stack(3);  // Стек максимум на 3 элемента

    std::cout << "Добавление элементов:\n";
    stack.push(10);  // OK
    stack.push(20);  // OK
    stack.push(30);  // OK
    stack.push(40);  // Переполнение!

    std::cout << "\nВерхний элемент: " << stack.top() << std::endl;
    std::cout << "Свободно мест: " << stack.available() << std::endl;

    // stack.size();  // ОШИБКА! Метод недоступен из-за приватного наследования

    return 0;
}
```

**Пояснение:**
- Приватное наследование означает "реализовано через"
- Все public и protected члены базового класса становятся private
- Используется для скрытия деталей реализации
- `using` позволяет выборочно сделать методы публичными
- Наследник не является базовым классом (не работает полиморфизм)


================================================================================


### Задание №213: Перегрузите оператор преобразования к bool

**Решение:**

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* str;
    int length;

public:
    String() : str(nullptr), length(0) {
        str = new char[1];
        str[0] = '\0';
    }

    String(const char* s) {
        if (s == nullptr || s[0] == '\0') {
            str = new char[1];
            str[0] = '\0';
            length = 0;
        } else {
            length = strlen(s);
            str = new char[length + 1];
            strcpy(str, s);
        }
    }

    ~String() {
        delete[] str;
    }

    // Оператор преобразования к bool
    // Возвращает true, если строка не пуста
    explicit operator bool() const {
        return length > 0 && str != nullptr && str[0] != '\0';
    }

    // Альтернатива: оператор ! для проверки пустоты
    bool operator!() const {
        return length == 0 || str == nullptr || str[0] == '\0';
    }

    void print() const {
        std::cout << (str ? str : "(null)") << std::endl;
    }

    int getLength() const {
        return length;
    }
};

// Пример для SmartPointer
template<typename T>
class SmartPointer {
private:
    T* ptr;

public:
    SmartPointer(T* p = nullptr) : ptr(p) {}

    ~SmartPointer() {
        delete ptr;
    }

    // Оператор преобразования к bool - проверяет, не nullptr ли указатель
    explicit operator bool() const {
        return ptr != nullptr;
    }

    T& operator*() const {
        return *ptr;
    }

    T* operator->() const {
        return ptr;
    }
};

int main() {
    String s1("Привет");
    String s2("");
    String s3;

    // Использование оператора bool в условиях
    if (s1) {
        std::cout << "s1 не пуста\n";
    }

    if (!s2) {
        std::cout << "s2 пуста\n";
    }

    if (s3) {
        std::cout << "s3 не пуста\n";
    } else {
        std::cout << "s3 пуста\n";
    }

    // Пример со SmartPointer
    SmartPointer<int> ptr1(new int(42));
    SmartPointer<int> ptr2(nullptr);

    if (ptr1) {
        std::cout << "ptr1 указывает на: " << *ptr1 << std::endl;
    }

    if (!ptr2) {
        std::cout << "ptr2 является nullptr\n";
    }

    // Благодаря explicit нельзя использовать неявное преобразование:
    // bool b = s1;  // ОШИБКА компиляции!
    bool b = static_cast<bool>(s1);  // OK - явное преобразование

    return 0;
}
```

**Пояснение:**
- `operator bool()` позволяет использовать объект в логических выражениях
- `explicit` предотвращает неявные преобразования
- Часто используется для проверки валидности объекта
- Удобно для умных указателей, строк, потоков ввода-вывода


================================================================================


### Задание №220: Реализуйте все операторы сравнения через spaceship оператор <=>

**Решение (C++20):**

```cpp
#include <iostream>
#include <compare>

class Point {
private:
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // Spaceship оператор (C++20)
    // Автоматически генерирует ==, !=, <, <=, >, >=
    auto operator<=>(const Point& other) const = default;

    void print() const {
        std::cout << "(" << x << ", " << y << ")";
    }
};

// Пример с ручной реализацией
class Version {
private:
    int major, minor, patch;

public:
    Version(int maj = 0, int min = 0, int p = 0) 
        : major(maj), minor(min), patch(p) {}

    // Ручная реализация spaceship оператора
    std::strong_ordering operator<=>(const Version& other) const {
        if (auto cmp = major <=> other.major; cmp != 0)
            return cmp;
        if (auto cmp = minor <=> other.minor; cmp != 0)
            return cmp;
        return patch <=> other.patch;
    }

    // Оператор == нужно определить отдельно
    bool operator==(const Version& other) const = default;

    void print() const {
        std::cout << major << "." << minor << "." << patch;
    }
};

int main() {
    Point p1(1, 2);
    Point p2(1, 3);
    Point p3(1, 2);

    std::cout << "Сравнение точек:\n";

    if (p1 == p3) {
        std::cout << "p1 == p3\n";
    }

    if (p1 != p2) {
        std::cout << "p1 != p2\n";
    }

    if (p1 < p2) {
        std::cout << "p1 < p2\n";
    }

    std::cout << "\nСравнение версий:\n";

    Version v1(1, 2, 3);
    Version v2(1, 2, 4);
    Version v3(2, 0, 0);

    if (v1 < v2) {
        v1.print(); 
        std::cout << " < "; 
        v2.print(); 
        std::cout << std::endl;
    }

    if (v2 < v3) {
        v2.print(); 
        std::cout << " < "; 
        v3.print(); 
        std::cout << std::endl;
    }

    return 0;
}
```

**Пояснение (для C++20):**
- Оператор `<=>` (spaceship) возвращает результат трехстороннего сравнения
- `= default` автоматически сравнивает все поля по порядку
- Автоматически генерируются все 6 операторов сравнения
- Возвращаемые типы: `strong_ordering`, `weak_ordering`, `partial_ordering`

**Решение для C++11/14/17 (без spaceship):**

```cpp
#include <iostream>

class Point {
private:
    int x, y;

public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // Базовые операторы
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }

    bool operator<(const Point& other) const {
        if (x != other.x) return x < other.x;
        return y < other.y;
    }

    // Остальные операторы через базовые
    bool operator!=(const Point& other) const {
        return !(*this == other);
    }

    bool operator>(const Point& other) const {
        return other < *this;
    }

    bool operator<=(const Point& other) const {
        return !(other < *this);
    }

    bool operator>=(const Point& other) const {
        return !(*this < other);
    }

    void print() const {
        std::cout << "(" << x << ", " << y << ")";
    }
};

int main() {
    Point p1(1, 2);
    Point p2(1, 3);

    if (p1 < p2) {
        std::cout << "p1 < p2\n";
    }

    if (p1 <= p2) {
        std::cout << "p1 <= p2\n";
    }

    return 0;
}
```


================================================================================


### Задание №221: Создайте статическое поле count для подсчета объектов класса

**Решение:**

```cpp
#include <iostream>

class Student {
private:
    std::string name;
    int age;

    // Статическое поле для подсчета объектов
    static int count;

public:
    // Конструктор - увеличивает счетчик
    Student(const std::string& n = "", int a = 0) : name(n), age(a) {
        count++;
        std::cout << "Создан студент #" << count << ": " << name << std::endl;
    }

    // Конструктор копирования - тоже увеличивает счетчик
    Student(const Student& other) : name(other.name), age(other.age) {
        count++;
        std::cout << "Скопирован студент #" << count << ": " << name << std::endl;
    }

    // Деструктор - уменьшает счетчик
    ~Student() {
        count--;
        std::cout << "Удален студент: " << name 
                  << " (осталось: " << count << ")\n";
    }

    // Статический метод для получения количества объектов
    static int getCount() {
        return count;
    }

    // Статический метод для вывода информации
    static void printCount() {
        std::cout << "Всего студентов: " << count << std::endl;
    }

    void print() const {
        std::cout << "Студент: " << name << ", возраст: " << age << std::endl;
    }
};

// Инициализация статического поля ВНЕ класса
int Student::count = 0;

void createStudents() {
    std::cout << "\n=== Создание локальных объектов ===\n";
    Student s1("Иван", 20);
    Student s2("Мария", 19);
    Student::printCount();

    std::cout << "\n=== Выход из функции ===\n";
    // Здесь s1 и s2 будут уничтожены
}

int main() {
    std::cout << "Начальное количество: " << Student::getCount() << "\n\n";

    Student* s1 = new Student("Петр", 21);
    Student* s2 = new Student("Анна", 20);

    std::cout << "\nКоличество студентов: " << Student::getCount() << "\n";

    createStudents();

    std::cout << "\nПосле выхода из функции: " << Student::getCount() << "\n";

    delete s1;
    std::cout << "После удаления s1: " << Student::getCount() << "\n";

    delete s2;
    std::cout << "После удаления s2: " << Student::getCount() << "\n";

    return 0;
}
```

**Пояснение:**
- `static int count` - статическое поле, общее для всех объектов
- Инициализируется ВНЕ класса: `int Student::count = 0;`
- Увеличивается в конструкторе, уменьшается в деструкторе
- Доступно через имя класса: `Student::count`
- Статический метод может обращаться только к статическим членам


================================================================================


### Задание №261: Реализуйте friend функцию для бинарной операции с разными типами

**Решение:**

```cpp
#include <iostream>

// Предварительное объявление классов
class Meter;
class Centimeter;

// Класс для метров
class Meter {
private:
    double value;

public:
    Meter(double v = 0.0) : value(v) {}

    double getValue() const { return value; }

    // Дружественная функция для сложения Meter + Centimeter
    friend Meter operator+(const Meter& m, const Centimeter& cm);

    // Дружественная функция для вывода
    friend std::ostream& operator<<(std::ostream& os, const Meter& m);
};

// Класс для сантиметров
class Centimeter {
private:
    double value;

public:
    Centimeter(double v = 0.0) : value(v) {}

    double getValue() const { return value; }

    // Дружественная функция для сложения Centimeter + Meter
    friend Meter operator+(const Centimeter& cm, const Meter& m);

    // Дружественная функция для сложения Meter + Centimeter
    friend Meter operator+(const Meter& m, const Centimeter& cm);

    friend std::ostream& operator<<(std::ostream& os, const Centimeter& cm);
};

// Реализация дружественной функции сложения Meter + Centimeter
Meter operator+(const Meter& m, const Centimeter& cm) {
    // Доступ к приватным полям обоих классов
    return Meter(m.value + cm.value / 100.0);
}

// Реализация сложения Centimeter + Meter (коммутативность)
Meter operator+(const Centimeter& cm, const Meter& m) {
    return m + cm;  // Используем уже определенный оператор
}

// Операторы вывода
std::ostream& operator<<(std::ostream& os, const Meter& m) {
    os << m.value << " м";
    return os;
}

std::ostream& operator<<(std::ostream& os, const Centimeter& cm) {
    os << cm.value << " см";
    return os;
}

// Более сложный пример - комплексные числа и вещественные
class Complex {
private:
    double real, imag;

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // Дружественная функция: Complex + double
    friend Complex operator+(const Complex& c, double d);

    // Дружественная функция: double + Complex
    friend Complex operator+(double d, const Complex& c);

    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
};

Complex operator+(const Complex& c, double d) {
    return Complex(c.real + d, c.imag);
}

Complex operator+(double d, const Complex& c) {
    return c + d;  // Коммутативность
}

std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << c.real;
    if (c.imag >= 0) os << "+";
    os << c.imag << "i";
    return os;
}

int main() {
    std::cout << "=== Пример 1: Метры и сантиметры ===\n";
    Meter m(2.5);           // 2.5 метра
    Centimeter cm(150);     // 150 сантиметров

    std::cout << "m = " << m << std::endl;
    std::cout << "cm = " << cm << std::endl;

    Meter result1 = m + cm;  // Meter + Centimeter
    std::cout << "m + cm = " << result1 << std::endl;

    Meter result2 = cm + m;  // Centimeter + Meter (коммутативность)
    std::cout << "cm + m = " << result2 << std::endl;

    std::cout << "\n=== Пример 2: Комплексные числа ===\n";
    Complex c1(3, 4);       // 3+4i
    double d = 5.0;

    std::cout << "c1 = " << c1 << std::endl;
    std::cout << "d = " << d << std::endl;

    Complex c2 = c1 + d;    // Complex + double
    std::cout << "c1 + d = " << c2 << std::endl;

    Complex c3 = d + c1;    // double + Complex
    std::cout << "d + c1 = " << c3 << std::endl;

    return 0;
}
```

**Пояснение:**
- Friend функции нужны для операций между разными классами
- Имеют доступ к приватным членам обоих классов
- Объявляются внутри класса с ключевым словом `friend`
- Определяются вне класса как обычные функции
- Полезны для коммутативных операций (a + b = b + a)
- Позволяют перегружать операторы для несимметричных типов


================================================================================
