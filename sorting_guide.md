# Полное руководство по сортировке массивов в C++

## Оглавление
1. [Введение](#введение)
2. [Простые алгоритмы сортировки](#простые-алгоритмы-сортировки)
3. [Продвинутые алгоритмы сортировки](#продвинутые-алгоритмы-сортировки)
4. [Анализ сложности](#анализ-сложности)
5. [50 заданий на закрепление](#50-заданий-на-закрепление)

---

## Введение

**Сортировка** - это процесс расположения элементов массива в определённом порядке (обычно по возрастанию или убыванию). Сортировка является одной из фундаментальных операций в программировании и компьютерной науке.

### Основные понятия

- **Стабильная сортировка**: сохраняет относительный порядок элементов с одинаковыми ключами
- **Нестабильная сортировка**: может изменять относительный порядок элементов с одинаковыми ключами
- **In-place сортировка**: требует O(1) дополнительной памяти
- **Внешняя сортировка**: требует O(n) дополнительной памяти

---

## Простые алгоритмы сортировки

### 1. Сортировка пузырьком (Bubble Sort)

#### Описание

Bubble Sort - это самый простой алгоритм сортировки. Алгоритм работает путём повторяющихся проходов по массиву, на каждом проходе сравнивая соседние элементы и обменивая их местами, если они находятся в неправильном порядке. После каждого прохода самый большой элемент "всплывает" на правильную позицию в конце массива.

#### Как это работает

1. Начинаем с первого элемента массива
2. Сравниваем текущий элемент со следующим
3. Если текущий элемент больше следующего - меняем их местами
4. Переходим к следующей паре
5. После каждого полного прохода наибольший элемент занимает свою позицию
6. Повторяем процесс для оставшейся части массива

#### Визуальный пример

```
Исходный массив: [5, 2, 8, 1, 9]

Проход 1:
[2, 5, 8, 1, 9]  <- 2 < 5, менять
[2, 5, 8, 1, 9]  <- 5 < 8, не менять
[2, 5, 1, 8, 9]  <- 1 < 8, менять
[2, 5, 1, 8, 9]  <- 8 < 9, не менять

Проход 2:
[2, 5, 1, 8, 9]
[2, 1, 5, 8, 9]
[2, 1, 5, 8, 9]
...
```

#### Реализация на C++

```cpp
#include <iostream>
#include <vector>
using namespace std;

void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    
    // Внешний цикл - количество проходов
    for (int i = 0; i < n - 1; i++) {
        // Флаг для оптимизации - если не было перестановок, массив отсортирован
        bool swapped = false;
        
        // Внутренний цикл - сравнение соседних элементов
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Обмен элементов
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        
        // Если не было перестановок, массив уже отсортирован
        if (!swapped) break;
    }
}

int main() {
    vector<int> arr = {5, 2, 8, 1, 9};
    bubbleSort(arr);
    
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;  // Вывод: 1 2 5 8 9
    
    return 0;
}
```

#### Анализ сложности

| Метрика | Значение |
|---------|----------|
| **Лучший случай** | O(n) |
| **Средний случай** | O(n²) |
| **Худший случай** | O(n²) |
| **Дополнительная память** | O(1) |
| **Стабильность** | Да |
| **In-place** | Да |

#### Преимущества и недостатки

**Преимущества:**
- Очень простой для понимания и реализации
- In-place алгоритм (не требует дополнительной памяти)
- Стабилен
- Хорошо работает для уже отсортированных массивов с оптимизацией

**Недостатки:**
- Очень медленен для больших массивов
- Квадратичная сложность даже в среднем случае
- Множество ненужных сравнений и перестановок

---

### 2. Сортировка выбором (Selection Sort)

#### Описание

Selection Sort работает путём выбора минимального элемента из неотсортированной части массива и размещения его в начало отсортированной части. Процесс повторяется для оставшейся части массива.

#### Как это работает

1. Находим минимальный элемент в оставшейся части массива
2. Обмениваем его с первым элементом неотсортированной части
3. Сдвигаем границу отсортированной части на один элемент вправо
4. Повторяем процесс для оставшейся части массива

#### Визуальный пример

```
Исходный массив: [5, 2, 8, 1, 9]

Шаг 1: Находим минимум (1), меняем с первым
[1, 2, 8, 5, 9]  <- 1 выбран

Шаг 2: Находим минимум в [2, 8, 5, 9] (это 2)
[1, 2, 8, 5, 9]  <- 2 уже на месте

Шаг 3: Находим минимум в [8, 5, 9] (это 5)
[1, 2, 5, 8, 9]  <- 5 выбран

Шаг 4: Находим минимум в [8, 9] (это 8)
[1, 2, 5, 8, 9]  <- 8 уже на месте

Результат: [1, 2, 5, 8, 9]
```

#### Реализация на C++

```cpp
void selectionSort(vector<int>& arr) {
    int n = arr.size();
    
    // Проходим по всему массиву
    for (int i = 0; i < n - 1; i++) {
        // Находим индекс минимального элемента в оставшейся части
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        // Обмениваем минимальный элемент с текущим
        swap(arr[i], arr[minIndex]);
    }
}
```

#### Анализ сложности

| Метрика | Значение |
|---------|----------|
| **Лучший случай** | O(n²) |
| **Средний случай** | O(n²) |
| **Худший случай** | O(n²) |
| **Дополнительная память** | O(1) |
| **Стабильность** | Нет |
| **In-place** | Да |

#### Преимущества и недостатки

**Преимущества:**
- Простой для понимания
- In-place алгоритм
- Гарантированное количество обменов: максимум n-1 обмен
- Хорош для маленьких массивов

**Недостатки:**
- Всегда O(n²) независимо от исходных данных
- Нестабилен
- Медленнее, чем Insertion Sort для большинства случаев

---

### 3. Сортировка вставками (Insertion Sort)

#### Описание

Insertion Sort работает путём постепенного построения отсортированного массива. На каждом шаге берется элемент из неотсортированной части и вставляется в правильную позицию в отсортированную часть.

#### Как это работает

1. Начинаем со второго элемента (первый считаем отсортированным)
2. Сравниваем его с элементами слева
3. Сдвигаем большие элементы на одну позицию вправо
4. Вставляем элемент на найденную позицию
5. Повторяем для всех оставшихся элементов

#### Визуальный пример

```
Исходный массив: [5, 2, 8, 1, 9]

Шаг 1: [5] | [2, 8, 1, 9]
Вставляем 2: [2, 5] | [8, 1, 9]

Шаг 2: [2, 5] | [8, 1, 9]
Вставляем 8: [2, 5, 8] | [1, 9]

Шаг 3: [2, 5, 8] | [1, 9]
Вставляем 1: [1, 2, 5, 8] | [9]

Шаг 4: [1, 2, 5, 8] | [9]
Вставляем 9: [1, 2, 5, 8, 9] | []

Результат: [1, 2, 5, 8, 9]
```

#### Реализация на C++

```cpp
void insertionSort(vector<int>& arr) {
    int n = arr.size();
    
    // Начинаем со второго элемента
    for (int i = 1; i < n; i++) {
        int key = arr[i];  // Элемент для вставки
        int j = i - 1;     // Индекс для сравнения
        
        // Сдвигаем элементы больше key на одну позицию вправо
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // Вставляем key на правильную позицию
        arr[j + 1] = key;
    }
}
```

#### Анализ сложности

| Метрика | Значение |
|---------|----------|
| **Лучший случай** | O(n) |
| **Средний случай** | O(n²) |
| **Худший случай** | O(n²) |
| **Дополнительная память** | O(1) |
| **Стабильность** | Да |
| **In-place** | Да |

#### Преимущества и недостатки

**Преимущества:**
- Простой для понимания и реализации
- Очень эффективен для маленьких массивов
- Очень эффективен для уже отсортированных или почти отсортированных массивов - O(n)
- In-place и стабилен
- Адаптивен - быстрее на частично отсортированных массивах

**Недостатки:**
- O(n²) в худшем и среднем случаях
- Медленнее, чем продвинутые алгоритмы на больших массивах

---

## Продвинутые алгоритмы сортировки

### 4. Быстрая сортировка (Quick Sort)

#### Описание

Quick Sort - это один из самых быстрых алгоритмов сортировки в среднем случае. Использует принцип "разделяй и властвуй". Выбирает опорный элемент (pivot) и разделяет массив на две части: элементы меньше опоры и элементы больше опоры. Затем рекурсивно сортирует обе части.

#### Как это работает

1. Выбираем опорный элемент (pivot) из массива
2. Разделяем массив так, чтобы все элементы < pivot находились слева, а все элементы > pivot - справа
3. Рекурсивно применяем Quick Sort к левой части
4. Рекурсивно применяем Quick Sort к правой части

#### Визуальный пример

```
Исходный массив: [5, 2, 8, 1, 9]
Выбираем pivot = 5

После разделения:
[2, 1] | [5] | [8, 9]
 left    pivot  right

Рекурсивно сортируем левую часть [2, 1]:
[1] | [2] | []

Рекурсивно сортируем правую часть [8, 9]:
[] | [8] | [9]

Результат: [1, 2, 5, 8, 9]
```

#### Реализация на C++

```cpp
// Функция разделения
int partition(vector<int>& arr, int low, int high) {
    // Выбираем последний элемент как pivot
    int pivot = arr[high];
    
    // Индекс для разделения
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

// Основная функция Quick Sort
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        // Получаем индекс разделения
        int pi = partition(arr, low, high);
        
        // Рекурсивно сортируем левую часть
        quickSort(arr, low, pi - 1);
        
        // Рекурсивно сортируем правую часть
        quickSort(arr, pi + 1, high);
    }
}

// Вспомогательная функция для вызова
void quickSortHelper(vector<int>& arr) {
    if (arr.size() > 0) {
        quickSort(arr, 0, arr.size() - 1);
    }
}
```

#### Анализ сложности

| Метрика | Значение |
|---------|----------|
| **Лучший случай** | O(n log n) |
| **Средний случай** | O(n log n) |
| **Худший случай** | O(n²) |
| **Дополнительная память** | O(log n) |
| **Стабильность** | Нет |
| **In-place** | Да |

#### Преимущества и недостатки

**Преимущества:**
- Очень быстрый на практике, часто быстрее других O(n log n) алгоритмов
- Хорошее использование кэша
- In-place алгоритм
- Адаптивен для различных типов данных

**Недостатки:**
- В худшем случае O(n²) (если всегда выбирается наихудший pivot)
- Нестабилен
- Требует рекурсии (может привести к переполнению стека)
- Зависит от выбора опорного элемента

---

### 5. Сортировка слиянием (Merge Sort)

#### Описание

Merge Sort - это стабильный алгоритм сортировки, который использует принцип "разделяй и властвуй". Разделяет массив на половины, рекурсивно сортирует каждую половину, а затем сливает отсортированные половины в единый отсортированный массив.

#### Как это работает

1. Разделяем массив на две половины
2. Рекурсивно применяем Merge Sort к левой половине
3. Рекурсивно применяем Merge Sort к правой половине
4. Объединяем две отсортированные половины в один массив

#### Визуальный пример

```
Исходный массив: [5, 2, 8, 1, 9]

Разделение:
         [5, 2, 8, 1, 9]
        /              \
    [5, 2, 8]        [1, 9]
    /        \       /     \
  [5, 2]    [8]    [1]     [9]
  /   \     |      |        |
[5]   [2]   [8]   [1]      [9]

Слияние (снизу вверх):
[2, 5]    [8]    [1]      [9]
  \       /      \         /
   [2, 5, 8]      [1, 9]
        \         /
      [1, 2, 5, 8, 9]

Результат: [1, 2, 5, 8, 9]
```

#### Реализация на C++

```cpp
// Функция слияния двух отсортированных подмассивов
void merge(vector<int>& arr, int left, int mid, int right) {
    // Размеры подмассивов
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    // Создаём временные массивы
    vector<int> leftArr(n1);
    vector<int> rightArr(n2);
    
    // Копируем данные в временные массивы
    for (int i = 0; i < n1; i++)
        leftArr[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        rightArr[j] = arr[mid + 1 + j];
    
    int i = 0, j = 0, k = left;
    
    // Объединяем временные массивы обратно в arr
    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k] = leftArr[i];
            i++;
        } else {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }
    
    // Копируем оставшиеся элементы из leftArr
    while (i < n1) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }
    
    // Копируем оставшиеся элементы из rightArr
    while (j < n2) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}

// Основная функция Merge Sort
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        // Сортируем первую половину
        mergeSort(arr, left, mid);
        
        // Сортируем вторую половину
        mergeSort(arr, mid + 1, right);
        
        // Объединяем отсортированные половины
        merge(arr, left, mid, right);
    }
}

// Вспомогательная функция для вызова
void mergeSortHelper(vector<int>& arr) {
    if (arr.size() > 0) {
        mergeSort(arr, 0, arr.size() - 1);
    }
}
```

#### Анализ сложности

| Метрика | Значение |
|---------|----------|
| **Лучший случай** | O(n log n) |
| **Средний случай** | O(n log n) |
| **Худший случай** | O(n log n) |
| **Дополнительная память** | O(n) |
| **Стабильность** | Да |
| **In-place** | Нет |

#### Преимущества и недостатки

**Преимущества:**
- Гарантированный O(n log n) во всех случаях
- Стабилен
- Предсказуемая производительность
- Хорош для связных списков

**Недостатки:**
- Требует O(n) дополнительной памяти
- Медленнее, чем Quick Sort на практике из-за копирования
- Не in-place

---

### 6. Пирамидальная сортировка (Heap Sort)

#### Описание

Heap Sort использует структуру данных "Двоичная куча" (heap). Сначала строит максимальную кучу из элементов массива, затем многократно извлекает максимальный элемент из кучи и помещает его в конец отсортированного массива.

#### Как это работает

1. Строим максимальную кучу из всех элементов массива
2. Обмениваем первый элемент (максимум) с последним элементом кучи
3. Уменьшаем размер кучи на 1 и "просеиваем" новый корневой элемент
4. Повторяем процесс пока размер кучи > 1

#### Визуальный пример

```
Исходный массив: [5, 2, 8, 1, 9]

Шаг 1: Строим максимальную кучу
        9
       / \
      5   8
     / \
    2   1

Шаг 2: Обмениваем 9 и 1, уменьшаем размер
        8
       / \
      5   1
     /
    2
Результат с 9: [?, ?, ?, ?, 9]

Шаг 3: Просеиваем
        8
       / \
      5   1
     /
    2

Обмениваем 8 и 2, уменьшаем размер
        5
       / \
      2   1
Результат: [?, ?, ?, 8, 9]

И так далее...
```

#### Реализация на C++

```cpp
// Функция для просеивания (heapify)
void heapify(vector<int>& arr, int n, int i) {
    int largest = i;           // Инициализируем largest как текущий узел
    int left = 2 * i + 1;      // Левый потомок
    int right = 2 * i + 2;     // Правый потомок
    
    // Если левый потомок больше, чем largest
    if (left < n && arr[left] > arr[largest])
        largest = left;
    
    // Если правый потомок больше, чем largest
    if (right < n && arr[right] > arr[largest])
        largest = right;
    
    // Если largest не i, обмениваем и рекурсивно heapify
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

// Основная функция Heap Sort
void heapSort(vector<int>& arr) {
    int n = arr.size();
    
    // Строим максимальную кучу
    // Начинаем с последнего внутреннего узла
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);
    
    // Один за другим извлекаем элементы из кучи
    for (int i = n - 1; i > 0; i--) {
        // Обмениваем текущий корень (максимум) с последним элементом
        swap(arr[0], arr[i]);
        
        // Вызываем heapify для сокращённой кучи
        heapify(arr, i, 0);
    }
}
```

#### Анализ сложности

| Метрика | Значение |
|---------|----------|
| **Лучший случай** | O(n log n) |
| **Средний случай** | O(n log n) |
| **Худший случай** | O(n log n) |
| **Дополнительная память** | O(1) |
| **Стабильность** | Нет |
| **In-place** | Да |

#### Преимущества и недостатки

**Преимущества:**
- Гарантированный O(n log n) во всех случаях
- In-place алгоритм
- Хорош для больших наборов данных

**Недостатки:**
- Медленнее, чем Quick Sort на практике
- Нестабилен
- Плохое использование кэша

---

## Анализ сложности

### Сравнительная таблица всех алгоритмов

| Алгоритм | Лучший случай | Средний случай | Худший случай | Память | Стабилен | In-place |
|----------|---------------|----------------|---------------|--------|----------|----------|
| **Bubble Sort** | O(n) | O(n²) | O(n²) | O(1) | Да | Да |
| **Selection Sort** | O(n²) | O(n²) | O(n²) | O(1) | Нет | Да |
| **Insertion Sort** | O(n) | O(n²) | O(n²) | O(1) | Да | Да |
| **Quick Sort** | O(n log n) | O(n log n) | O(n²) | O(log n) | Нет | Да |
| **Merge Sort** | O(n log n) | O(n log n) | O(n log n) | O(n) | Да | Нет |
| **Heap Sort** | O(n log n) | O(n log n) | O(n log n) | O(1) | Нет | Да |

### Рекомендации по использованию

- **Маленькие массивы (< 50 элементов)**: Insertion Sort
- **Почти отсортированные данные**: Insertion Sort
- **Общий случай**: Quick Sort
- **Гарантированная O(n log n)**: Merge Sort или Heap Sort
- **Нужна стабильность**: Merge Sort или Insertion Sort
- **Ограничение на дополнительную память**: Quick Sort или Heap Sort

---

## 50 заданий на закрепление

### Базовые задания (1-15)

**Задание 1**: Реализуйте функцию, которая сортирует массив целых чисел в порядке возрастания, используя Bubble Sort. Входные данные: `[5, 2, 8, 1, 9]`. Ожидаемый результат: `[1, 2, 5, 8, 9]`.

**Задание 2**: Реализуйте Selection Sort и отсортируйте массив `[64, 34, 25, 12, 22, 11, 90]`.

**Задание 3**: Напишите функцию Insertion Sort, которая работает в порядке убывания (от большего к меньшему).

**Задание 4**: Реализуйте оптимизированную версию Bubble Sort с флагом `swapped` для выхода из цикла раньше.

**Задание 5**: Напишите программу, которая сравнивает количество операций в Bubble Sort и Selection Sort на массиве `[5, 2, 8, 1, 9, 3, 7]`.

**Задание 6**: Реализуйте Quick Sort с выбором случайного опорного элемента.

**Задание 7**: Напишите функцию для сортировки массива с помощью Merge Sort.

**Задание 8**: Реализуйте Heap Sort и отсортируйте массив `[10, 5, 20, 2, 8]`.

**Задание 9**: Создайте программу, которая сортирует массив строк в алфавитном порядке, используя Insertion Sort.

**Задание 10**: Напишите функцию, которая сортирует массив, но пропускает элементы, кратные 3.

**Задание 11**: Реализуйте Bubble Sort для массива вещественных чисел (float/double).

**Задание 12**: Напишите программу, которая проверяет, отсортирован ли массив, и выводит сообщение об этом.

**Задание 13**: Создайте функцию, которая находит медиану массива после сортировки.

**Задание 14**: Напишите программу для сортировки массива пар целых чисел по первому элементу пары.

**Задание 15**: Реализуйте сортировку массива символов в алфавитном порядке.

### Средние задания (16-35)

**Задание 16**: Реализуйте функцию для сортировки массива структур `struct Student { string name; int grade; }` по оценкам.

**Задание 17**: Напишите программу, которая сортирует два массива и объединяет их в один отсортированный массив.

**Задание 18**: Создайте функцию для циклической ротации массива, а затем его сортировки.

**Задание 19**: Реализуйте сортировку массива, где элементы чередуются между минимум и максимум.

**Задание 20**: Напишите программу для сортировки массива отрицательных и положительных чисел с отрицательными впереди.

**Задание 21**: Создайте функцию для сортировки массива цветов (красный, зелёный, синий) без использования встроенной функции сортировки.

**Задание 22**: Реализуйте стабильную сортировку массива структур по нескольким критериям.

**Задание 23**: Напишите программу для проверки стабильности различных алгоритмов сортировки.

**Задание 24**: Создайте функцию для сортировки в порядке убывания с использованием Merge Sort.

**Задание 25**: Реализуйте сортировку массива, где каждый элемент находится в диапазоне от k до k*k для малых k.

**Задание 26**: Напишите программу для сортировки массива с пропуском нулей (нули в конце).

**Задание 27**: Создайте функцию для сортировки массива таким образом, чтобы чётные числа были впереди, а нечётные сзади.

**Задание 28**: Реализуйте сортировку массива с сохранением информации об исходных индексах элементов.

**Задание 29**: Напишите программу для сортировки массива так, чтобы абсолютные значения были в порядке возрастания.

**Задание 30**: Создайте функцию для k-th наибольшего элемента в массиве, используя сортировку.

**Задание 31**: Реализуйте сортировку массива слов по их длине.

**Задание 32**: Напишите программу, которая сортирует матрицу построчно и по столбцам.

**Задание 33**: Создайте функцию для проверки, является ли отсортированный массив результатом применения конкретного алгоритма.

**Задание 34**: Реализуйте сортировку массива с использованием компаратора, переданного в качестве параметра.

**Задание 35**: Напишите программу для сортировки массива дат (день, месяц, год) в хронологическом порядке.

### Продвинутые задания (36-50)

**Задание 36**: Реализуйте гибридный алгоритм сортировки, который использует Quick Sort для больших массивов и Insertion Sort для маленьких.

**Задание 37**: Создайте функцию для сортировки массива из 2D координат по расстоянию от начала координат.

**Задание 38**: Напишите программу для сортировки массива с минимизацией количества сравнений.

**Задание 39**: Реализуйте сортировку массива, где каждый проход использует другой алгоритм.

**Задание 40**: Создайте функцию для поиска k-го наименьшего элемента в неотсортированном массиве за O(n) в среднем случае.

**Задание 41**: Напишите программу для сортировки массива с использованием параллельных вычислений (многопоточность).

**Задание 42**: Реализуйте внешнюю сортировку для файла, который не помещается в оперативную память.

**Задание 43**: Создайте функцию для "почти отсортированного" массива, где каждый элемент находится максимум на k позиций от его правильного положения.

**Задание 44**: Напишите программу для сортировки массива со сложными структурами данных и множественными критериями.

**Задание 45**: Реализуйте сортировку подсчётом (Counting Sort) для массива целых чисел в диапазоне [0, k].

**Задание 46**: Создайте функцию для сортировки массива с использованием Timsort алгоритма.

**Задание 47**: Напишите программу для анализа производительности разных алгоритмов сортировки на различных типах данных.

**Задание 48**: Реализуйте сортировку массива, минимизируя использование дополнительной памяти при Merge Sort.

**Задание 49**: Создайте функцию для поиска всех элементов, находящихся в правильном положении после частичной сортировки.

**Задание 50**: Напишите программу, которая автоматически выбирает оптимальный алгоритм сортировки на основе характеристик входного массива (размер, степень сортировки, тип данных).

---

## Полезные советы и лучшие практики

### Оптимизация производительности

1. **Выбор алгоритма**: Используйте правильный алгоритм для вашего сценария использования
2. **Кэширование**: Минимизируйте обращения к памяти
3. **Избегайте копирования**: Используйте ссылки и указатели где возможно
4. **Параллелизм**: Используйте многопоточность для очень больших массивов

### Отладка

1. **Печать промежуточных результатов**: Помогает понять, работает ли алгоритм правильно
2. **Юнит-тесты**: Тестируйте граничные случаи (пустой массив, один элемент, дубликаты)
3. **Профилирование**: Используйте профайлеры для поиска узких мест

### Часто встречающиеся ошибки

1. **Off-by-one ошибки**: Проверяйте граничные условия циклов
2. **Неправильные индексы**: Убедитесь, что вы используете правильные значения mid, left, right
3. **Переполнение стека**: Будьте осторожны с рекурсией на очень больших массивах

---

## Заключение

Сортировка - это фундаментальный навык в программировании. Понимание различных алгоритмов сортировки позволяет вам выбирать наиболее эффективное решение для конкретной задачи. Практикуйтесь в реализации этих алгоритмов и постепенно вы станете экспертом в их использовании.