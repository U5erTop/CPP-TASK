# Перегрузка функций, аргументы по умолчанию и конструктор копирования в C++

## Введение

В C++ три тесно связанные темы — перегрузка функций, аргументы по умолчанию и конструктор копирования — образуют основу «удобного» и безопасного интерфейса классов и библиотек.  
Перегрузка позволяет давать одному имени несколько реализаций, аргументы по умолчанию упрощают вызовы, а конструктор копирования управляет тем, как объекты копируются между собой.

---

## Перегрузка функций: идея и синтаксис

Перегрузка функции (function overloading) — это определение нескольких функций с одинаковым именем, но разными списками параметров (типами и/или количеством аргументов).
Компилятор выбирает нужную перегруженную функцию на этапе компиляции, анализируя типы фактических аргументов и применяя правила поиска «наиболее подходящего соответствия».

```cpp
#include <iostream>

void print(int x) {
    std::cout << "int: " << x << '\n';
}

void print(double x) {
    std::cout << "double: " << x << '\n';
}

void print(const char* s) {
    std::cout << "string: " << s << '\n';
}

int main() {
    print(10);        // вызов print(int)
    print(3.14);      // вызов print(double)
    print("Hello");   // вызов print(const char*)
}
```

Ключевые моменты:

- Различаться должны параметр‑типы или их количество.
- Нельзя перегружать функции, отличающиеся только возвращаемым типом.
- Учитывается только список параметров (без имён параметров и без информации о значениях по умолчанию).

---

## Как компилятор выбирает перегрузку

При вызове функции компилятор:

- Формирует множество кандидатных функций (подходящих по имени и видимости).
- Отбирает из них те, к которым можно преобразовать аргументы (стандартные, пользовательские преобразования).
- Выбирает лучшую: с минимальными и более «узкими» преобразованиями типов.

Если:

- Не нашлось ни одной подходящей функции — ошибка «no matching function».
- Подходит более одной и ни одна не лучше других — ошибка «ambiguous call».

---

## Ограничения и типичные ошибки при перегрузке

1. **Только возвращаемый тип — нельзя**

```cpp
int    foo(int x);
double foo(int x); // ОШИБКА: сигнатуры совпадают, только return отличается
```

2. **const/volatile для параметров по значению не создают отдельную перегрузку**

```cpp
void f(int x);
void f(const int x); // То же самое, что и f(int), конфликт
```

3. **Ссылки и указатели учитываются**

```cpp
void g(int& x);
void g(const int& x); // допустимая перегрузка: lvalue‑int без const и c const
```

4. **Шаблоны и обычные функции**

Часто пишут перегрузку в виде обычной функции плюс шаблон — при совпадении более «специализированная» версия выигрывает.

---

## Аргументы по умолчанию: идея и синтаксис

Аргументы по умолчанию (default arguments) позволяют не передавать некоторые параметры, если для них заранее определены значения:

```cpp
#include <iostream>

void logMessage(const std::string& text,
                int level = 1,
                bool toFile = false) {
    std::cout << "level=" << level << " text=" << text << '\n';
}

int main() {
    logMessage("Hello");             // level=1, toFile=false
    logMessage("Warn", 2);           // level=2, toFile=false
    logMessage("Error", 3, true);    // level=3, toFile=true
}
```

Правила:

- Значения по умолчанию задаются только в объявлении (как правило — в заголовочном файле).
- Все параметры **правее** параметра с аргументом по умолчанию тоже должны иметь аргументы по умолчанию.
- В одном и том же месте объявления параметру нельзя задавать значение по умолчанию более одного раза.

---

## Где можно использовать аргументы по умолчанию

- В обычных функциях.
- В методах классов (включая конструкторы).
- В конструкторах: это позволяет имитировать «перегрузку по количеству параметров» одним определением.

```cpp
class Point {
    int x, y;
public:
    Point(int x = 0, int y = 0)
        : x(x), y(y) {}
};

int main() {
    Point p1;        // (0,0)
    Point p2(10);    // (10,0)
    Point p3(2, 3);  // (2,3)
}
```

---

## Ограничения и подводные камни аргументов по умолчанию

1. **Значение по умолчанию подставляется на месте вызова**

Это значит, что при изменении значения по умолчанию нужно пересобирать каждую единицу трансляции, где функция вызывается.

2. **Не входят в сигнатуру функции**

Две функции, различающиеся только наличием аргументов по умолчанию, считаются одинаковыми (многократное объявление, а не перегрузка).

```cpp
void f(int x = 0);
void f(int x); // то же самое объявление, а не перегрузка
```

3. **Перегрузка vs default arguments**

Есть ситуации, когда лучше использовать перегрузку, а не значения по умолчанию, особенно если важна работа с указателями на функции или бинарная совместимость.

---

## Взаимодействие перегрузки и аргументов по умолчанию

Одна и та же функциональность может быть реализована двумя способами:

### Вариант 1: Перегрузка

```cpp
void draw(int x, int y, char ch);
void draw(int x, int y) {
    draw(x, y, '*');
}
```

### Вариант 2: Аргумент по умолчанию

```cpp
void draw(int x, int y, char ch = '*');
```

Рекомендации (упрощённо):

- Если необходимо ясно управлять набором допустимых сигнатур, удобнее перегрузка.
- Если функция редко принимает «не стандартные» значения, и важна краткость вызова — аргументы по умолчанию.

---

## Конструктор копирования: назначение и форма

Конструктор копирования — это особый конструктор, который создаёт новый объект как копию уже существующего объекта того же класса.
Его сигнатура: первый параметр имеет тип `T&`, `const T&`, `volatile T&` или `const volatile T&`; остальные (если есть) должны иметь значения по умолчанию.

```cpp
class Vector {
    int size;
    double* data;
public:
    // конструктор копирования
    Vector(const Vector& other)
        : size(other.size),
          data(new double[other.size])
    {
        for (int i = 0; i < size; ++i)
            data[i] = other.data[i];
    }
};
```

Если программист не объявил конструктор копирования сам, компилятор сгенерирует «неявный» конструктор копирования, который выполняет побитовое копирование нестатических полей (shallow copy).

---

## Когда компилятор вызывает конструктор копирования

Конструктор копирования вызывается, когда:

- Создаётся объект и инициализируется другим объектом того же типа:  
  `Vector v2 = v1;`
- Функция возвращает объект по значению (может быть оптимизировано RVO/NRVO).
- Объект передаётся в функцию по значению.

Пример:

```cpp
Vector makeVector() {
    Vector v(10);
    return v; // возможно, вызов конструктора копирования (или оптимизация)
}

void foo(Vector v); // v создаётся копированием аргумента
```

---

## Конструктор копирования с аргументами по умолчанию

По стандарту C++, конструктор считается копирующим, если:

- первый параметр — `T&`, `const T&`, `volatile T&` или `const volatile T&`;
- остальные параметры (если есть) имеют значения по умолчанию.

```cpp
class X {
public:
    X(const X& other, int mode = 0); // всё ещё копирующий конструктор
};
```

На практике такой приём используется редко — обычно у копирующего конструктора один параметр, чтобы не путать читателя и не усложнять вызовы.

---

## Глубокое vs поверхностное копирование

Если класс владеет ресурсами (динамическая память, файловые дескрипторы и т. д.), нужно **явно** реализовать копирующий конструктор (и оператор присваивания), чтобы сделать глубокую копию.

```cpp
class String {
    char* data;
public:
    String(const char* s = "") {
        size_t n = std::strlen(s);
        data = new char[n + 1];
        std::strcpy(data, s);
    }

    // Конструктор копирования: глубокое копирование
    String(const String& other) {
        size_t n = std::strlen(other.data);
        data = new char[n + 1];
        std::strcpy(data, other.data);
    }

    ~String() {
        delete[] data;
    }
};
```

Если оставить компиляторский конструктор копирования с поверхностным копированием, несколько объектов будут указывать на один и тот же буфер, что приведёт к двойному освобождению памяти и неопределённому поведению.

---

## Отношения между копирующим конструктором и перегрузкой

Конструктор — это тоже функция‑член, поэтому:

- Его можно перегружать по количеству и типам параметров.
- Один из этих конструкторов (с соответствующей сигнатурой) будет копирующим.

Пример:

```cpp
class Matrix {
    int rows, cols;
    double* data;
public:
    Matrix(int r, int c);
    Matrix(int n);               // квадратная матрица n × n
    Matrix(const Matrix& other); // копирующий конструктор
};
```

---

## Перегрузка конструкторов и делегирующие конструкторы

Современный C++ позволяет одному конструктору вызывать другой (делегирование), чтобы избежать дублирования кода.

```cpp
class Point {
    int x, y;
public:
    Point() : Point(0, 0) {}          // делегирование
    Point(int x) : Point(x, 0) {}     // делегирование
    Point(int x, int y) : x(x), y(y) {}
};
```

Такой подход уменьшает количество ошибок и делает логику инициализации более прозрачной.

---

## Типичные ошибки

1. **Перегрузка только по возвращаемому типу**

```cpp
int    parse(const std::string&);
double parse(const std::string&); // ошибка
```

2. **Смешивание перегрузки и аргументов по умолчанию так, что вызовы становятся неоднозначными**

```cpp
void f(int x, int y = 0);
void f(int x); // объявление дублирует первую функцию
```

3. **Отсутствие пользовательского конструктора копирования для класса с ресурсами**

- Утечки или двойное освобождение памяти.
- Неопределённое поведение при копировании.

4. **Определение разных значений по умолчанию в разных объявлениях**

```cpp
// header.h
void foo(int x = 10);

// source.cpp
void foo(int x = 20) { /* ... */ } // нарушает ODR, UB
```
