# Перегрузка операторов в C++

> Тема: operator overloading (перегрузка операторов) — как проектировать типы, чтобы они вели себя естественно в выражениях.

## 0. Ключевая идея

Перегрузка оператора в C++ — это объявление функции со специальным именем вида `operator+`, `operator==`, `operator[]` и т. п., чтобы стандартные операторы языка работали с пользовательскими типами (классами/структурами/enum).

Важно: перегрузка **не меняет**:

- приоритет и ассоциативность оператора,
- число операндов,
- правила вычисления выражения (за исключением того, что вы задаёте тело функции),
- поведение операторов для встроенных типов, если оба операнда — встроенные.

## 1. Ограничения и что нельзя перегружать

### 1.1 Операторы, которые нельзя перегружать

Нельзя перегружать: `.` , `::` , `?:` , `.*`.

### 1.2 Нельзя создавать новые операторы

Нельзя «придумать» новый оператор (`**`, `<>` и т. п.).

### 1.3 Нельзя менять арность/приоритет

`a+b*c` всегда будет интерпретироваться как `a+(b*c)` по приоритетам языка, даже если `+` и `*` перегружены.

## 2. Две формы: метод или свободная функция

Оператор перегружается как:

- **нестатический метод** класса, или
- **свободная функция** (в том числе `friend`).

### 2.1 Сколько параметров

- Унарный оператор:
  - метод: `T::operator-()` — параметров нет,
  - свободная: `operator-(T)` — один параметр.
- Бинарный оператор:
  - метод: `T::operator+(U rhs)` — один параметр,
  - свободная: `operator+(T lhs, U rhs)` — два параметра.

### 2.2 Что выбрать — метод или свободную

Практическое правило:

- `operator=`, `operator[]`, `operator()`, `operator->` — обычно **методы**.
- Арифметика и сравнения (`+`, `*`, `==`, `<`) — часто **свободные** функции, чтобы поддержать симметрию и выражения вида `2 + x`.

## 3. friend: когда нужен

Свободные операторы часто объявляют `friend`, чтобы получить доступ к `private` данным, но это не обязательно: можно реализовать через публичный интерфейс.

## 4. const-корректность

Если оператор логически не меняет объект, делайте его `const`:

- `T operator+(...) const` (если это метод),
- `bool operator==(const T&) const`,
- `const T& operator[](size_t) const`.

## 5. Идиома «сначала op=, потом op»

Для большинства типов удобно:

- реализовать `operator+=` (меняет объект и возвращает `*this` по ссылке),
- а `operator+` написать через копию и `+=`.

Это уменьшает дублирование логики и соответствует ожиданиям: `+` не меняет аргументы.

## 6. Возвращаемые значения: ссылка или значение

Типовые ожидания:

- `operator+=`, `operator*=`, префиксный `operator++` → возвращают `T&`.
- `operator+`, `operator*`, постфиксный `operator++(int)` → возвращают `T` (по значению).

## 7. Сравнения

### 7.1 Минимальный набор

Чаще всего достаточно:

- `operator==` и `operator<` (а остальные — через них),
  или в C++20 — `operator<=>`.

### 7.2 Согласованность

Если `a==b`, то должно быть true, что и `!(a<b)` и `!(b<a)` (для строгого порядка).

## 8. Инкремент/декремент

Сигнатуры:

```cpp
T& operator++();      // prefix
T  operator++(int);   // postfix
```

Постфикс возвращает «старое» значение копией, поэтому обычно дороже.

## 9. operator[] и operator()

### 9.1 operator[]

- Принимает **ровно один** индекс.
- Обычно делают две версии: const и non-const.

### 9.2 operator()

Можно делать сколько угодно параметров: удобно для матриц `m(r,c)`.

## 10. operator\* и operator->

Для «умных указателей»:

- `T& operator*() const`
- `T* operator->() const`

`operator->` должен возвращать указатель или объект, у которого снова есть `operator->`.

## 11. Потоки: operator<< и operator>>

Эти операторы почти всегда реализуют как свободные функции:

```cpp
std::ostream& operator<<(std::ostream&, const T&);
std::istream& operator>>(std::istream&, T&);
```

## 12. Преобразования: operator T()

Можно объявить оператор преобразования типа, например `operator bool() const`.
Рекомендация: избегать неявных преобразований, которые приводят к сюрпризам; часто стоит использовать `explicit operator bool()`.

## 13. Опасные перегрузки: &&, ||, ,

Перегруженные `&&`/`||` не дают короткого замыкания: оба операнда вычисляются, что ломает ожидаемую семантику.
Оператор запятая `,` тоже почти всегда ухудшает читабельность.

## 14. Типичные ошибки

- Возврат ссылки на временный объект из `operator+`.
- Несогласованность `==` и `<`.
- Отсутствие const-версий `operator[]`.
- Неявные преобразования без `explicit`, приводящие к неоднозначностям.

## 15. Большой пример: Fraction

Ниже — минимально практичный класс рациональных чисел, где:

- `+=` — основная операция,
- `+` — через `+=`,
- есть нормализация (сокращение дроби) и вывод.

```cpp
#include <iostream>
#include <numeric>
#include <stdexcept>

class Fraction {
    long long n = 0;
    long long d = 1;

    void normalize() {
        if (d == 0) throw std::invalid_argument("denominator is zero");
        if (d < 0) { d = -d; n = -n; }
        long long g = std::gcd(n, d);
        n /= g; d /= g;
    }

public:
    Fraction(long long num = 0, long long den = 1) : n(num), d(den) { normalize(); }

    Fraction& operator+=(const Fraction& r) {
        n = n * r.d + r.n * d;
        d = d * r.d;
        normalize();
        return *this;
    }

    friend Fraction operator+(Fraction l, const Fraction& r) {
        l += r;
        return l;
    }

    friend std::ostream& operator<<(std::ostream& os, const Fraction& f) {
        return os << f.n << '/' << f.d;
    }
};
```

## 16. Большой пример: Matrix с operator()

`operator()` позволяет естественно обращаться к элементу матрицы:

```cpp
#include <vector>
#include <cstddef>
#include <stdexcept>

class Matrix {
    std::size_t rows, cols;
    std::vector<double> a;

    std::size_t idx(std::size_t r, std::size_t c) const { return r * cols + c; }

public:
    Matrix(std::size_t r, std::size_t c) : rows(r), cols(c), a(r*c, 0.0) {}

    double& operator()(std::size_t r, std::size_t c) {
        if (r >= rows || c >= cols) throw std::out_of_range("index");
        return a[idx(r,c)];
    }

    double operator()(std::size_t r, std::size_t c) const {
        if (r >= rows || c >= cols) throw std::out_of_range("index");
        return a[idx(r,c)];
    }
};
```
